/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RelaySyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/ui/settings-tab.ts
var import_obsidian = require("obsidian");

// src/utils/crypto.ts
var CryptoHelper = class {
  /**
   * Генерирует криптографически стойкий ключ из пароля
   */
  static async generateKey(password, salt) {
    const encoder = new TextEncoder();
    const passwordBuffer = encoder.encode(password);
    if (!salt) {
      salt = crypto.getRandomValues(new Uint8Array(this.SALT_LENGTH));
    }
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      passwordBuffer,
      { name: "PBKDF2" },
      false,
      ["deriveKey"]
    );
    const key = await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: this.ITERATIONS,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: this.ALGORITHM, length: this.KEY_LENGTH },
      false,
      ["encrypt", "decrypt"]
    );
    return { key, salt };
  }
  /**
   * Шифрует данные с использованием AES-GCM
   */
  static async encrypt(data, password) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const { key, salt } = await this.generateKey(password);
    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
    const encryptedBuffer = await crypto.subtle.encrypt(
      {
        name: this.ALGORITHM,
        iv,
        tagLength: 128
        // Длина тега аутентификации в битах
      },
      key,
      dataBuffer
    );
    const encryptedArray = new Uint8Array(encryptedBuffer);
    const encryptedData = encryptedArray.slice(0, encryptedArray.length - 16);
    const authTag = encryptedArray.slice(encryptedArray.length - 16);
    return {
      iv: this.arrayBufferToBase64(iv),
      data: this.arrayBufferToBase64(encryptedData),
      authTag: this.arrayBufferToBase64(authTag),
      salt: this.arrayBufferToBase64(salt)
    };
  }
  /**
   * Дешифрует данные, зашифрованные с использованием AES-GCM
   */
  static async decrypt(encryptedData, password) {
    try {
      const iv = this.base64ToArrayBuffer(encryptedData.iv);
      const data = this.base64ToArrayBuffer(encryptedData.data);
      const authTag = this.base64ToArrayBuffer(encryptedData.authTag);
      const salt = this.base64ToArrayBuffer(encryptedData.salt);
      const encryptedBuffer = new Uint8Array(data.byteLength + authTag.byteLength);
      encryptedBuffer.set(new Uint8Array(data), 0);
      encryptedBuffer.set(new Uint8Array(authTag), data.byteLength);
      const { key } = await this.generateKey(password, new Uint8Array(salt));
      const decryptedBuffer = await crypto.subtle.decrypt(
        {
          name: this.ALGORITHM,
          iv: new Uint8Array(iv),
          tagLength: 128
        },
        key,
        encryptedBuffer
      );
      const decoder = new TextDecoder();
      return decoder.decode(decryptedBuffer);
    } catch (error) {
      console.error("Decryption failed:", error);
      throw new Error("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043E\u0432\u0430\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435. \u0412\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C \u0438\u043B\u0438 \u043F\u043E\u0432\u0440\u0435\u0436\u0434\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435.");
    }
  }
  /**
   * Преобразует ArrayBuffer в строку Base64
   */
  static arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  /**
   * Преобразует строку Base64 в ArrayBuffer
   */
  static base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  /**
   * Генерирует уникальный идентификатор устройства
   */
  static generateDeviceId() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(
      array,
      (byte) => byte.toString(16).padStart(2, "0")
    ).join("");
  }
  /**
   * Хеширует строку с использованием SHA-256
   */
  static async hashString(str) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    const hash = await crypto.subtle.digest("SHA-256", data);
    return this.arrayBufferToBase64(hash);
  }
};
CryptoHelper.ALGORITHM = "AES-GCM";
CryptoHelper.KEY_LENGTH = 256;
// bits
CryptoHelper.SALT_LENGTH = 16;
// bytes
CryptoHelper.IV_LENGTH = 12;
// bytes
CryptoHelper.ITERATIONS = 1e5;

// src/utils/device-id.ts
var DEVICE_ID_KEY = "relay-sync-device-id";
var DEVICE_NAME_KEY = "relay-sync-device-name";
var DeviceManager = class {
  /**
   * Получить идентификатор устройства или создать новый, если не существует
   */
  static getDeviceId() {
    let deviceId = localStorage.getItem(DEVICE_ID_KEY);
    if (!deviceId) {
      deviceId = CryptoHelper.generateDeviceId();
      localStorage.setItem(DEVICE_ID_KEY, deviceId);
    }
    return deviceId;
  }
  /**
   * Установить идентификатор устройства
   */
  static setDeviceId(deviceId) {
    localStorage.setItem(DEVICE_ID_KEY, deviceId);
  }
  /**
   * Получить имя устройства или вернуть значение по умолчанию
   */
  static getDeviceName() {
    const deviceName = localStorage.getItem(DEVICE_NAME_KEY);
    if (!deviceName) {
      const deviceType = this.detectDeviceType();
      const randomSuffix = Math.floor(Math.random() * 1e4);
      const newName = `${deviceType}-${randomSuffix}`;
      localStorage.setItem(DEVICE_NAME_KEY, newName);
      return newName;
    }
    return deviceName;
  }
  /**
   * Установить имя устройства
   */
  static setDeviceName(deviceName) {
    localStorage.setItem(DEVICE_NAME_KEY, deviceName);
  }
  /**
   * Определить тип устройства (ПК, Android, iOS)
   */
  static detectDeviceType() {
    const userAgent = navigator.userAgent.toLowerCase();
    if (/android/i.test(userAgent)) {
      return "Android";
    } else if (/iphone|ipad|ipod/i.test(userAgent)) {
      return "iOS";
    } else if (/windows/i.test(userAgent)) {
      return "Windows";
    } else if (/macintosh/i.test(userAgent)) {
      return "Mac";
    } else if (/linux/i.test(userAgent)) {
      return "Linux";
    } else {
      return "Unknown";
    }
  }
};

// src/ui/settings-tab.ts
var KeyInputModal = class extends import_obsidian.Modal {
  constructor(app, props) {
    super(app);
    this.onSubmitCallback = props.onSubmit;
    this.onClose = props.onClose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("relay-sync-modal-content");
    contentEl.createEl("h2", { text: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F" });
    contentEl.createEl("p", {
      text: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043B\u044E\u0447, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043D\u044B\u0439 \u043E\u0442 \u0434\u0440\u0443\u0433\u043E\u0433\u043E \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F, \u0434\u043B\u044F \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043A \u0435\u0433\u043E \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443.",
      cls: "relay-sync-modal-description"
    });
    const inputContainer = contentEl.createDiv({
      cls: "relay-sync-key-input-container"
    });
    this.keyInput = new import_obsidian.TextComponent(inputContainer).setPlaceholder("XXXXXXXX").setValue("");
    this.keyInput.inputEl.style.textTransform = "uppercase";
    const helpText = contentEl.createEl("p", {
      text: "\u041A\u043B\u044E\u0447 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u0446\u0438\u0444\u0440\u044B, \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 6 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432.",
      cls: "relay-sync-key-help"
    });
    this.statusMessage = contentEl.createEl("div", {
      cls: "relay-sync-status-message",
      text: ""
    });
    this.keyInput.inputEl.addEventListener("input", () => {
      const value = this.keyInput.getValue();
      const formatted = value.replace(/[^a-zA-Z0-9]/g, "").toUpperCase();
      if (value !== formatted) {
        this.keyInput.setValue(formatted);
      }
      if (formatted.length < 6) {
        this.statusMessage.setText("\u041A\u043B\u044E\u0447 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 6 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432");
        this.statusMessage.style.color = "orange";
      } else {
        this.statusMessage.setText("\u041A\u043B\u044E\u0447 \u0432\u0430\u043B\u0438\u0434\u0435\u043D, \u0433\u043E\u0442\u043E\u0432 \u043A \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435");
        this.statusMessage.style.color = "green";
      }
    });
    const buttonContainer = contentEl.createDiv({
      cls: "relay-sync-modal-buttons"
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("\u041E\u0442\u043C\u0435\u043D\u0430").onClick(() => {
      this.close();
    });
    const submitKey = () => {
      const key = this.keyInput.getValue().trim();
      if (key.length < 6) {
        this.statusMessage.setText("\u041A\u043B\u044E\u0447 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 6 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432");
        this.statusMessage.style.color = "red";
        return;
      }
      this.statusMessage.setText("\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
      this.statusMessage.style.color = "blue";
      new import_obsidian.Notice("\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
      this.onSubmitCallback(key);
      this.close();
    };
    this.keyInput.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        submitKey();
      }
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F").setCta().onClick(submitKey);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SyncRequestModal = class extends import_obsidian.Modal {
  constructor(app, request, onAccept, onDecline) {
    super(app);
    this.request = request;
    this.onAccept = onAccept;
    this.onDecline = onDecline;
  }
  onOpen() {
    const { contentEl } = this;
    const { deviceName, requestId } = this.request;
    contentEl.empty();
    contentEl.addClass("relay-sync-modal-content");
    contentEl.createEl("h2", { text: "\u0417\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E" });
    contentEl.createEl("p", {
      text: `\u0423\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E "${deviceName || "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E\u0435"}" \u0437\u0430\u043F\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0434\u043E\u0441\u0442\u0443\u043F \u043A \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438.`,
      cls: "relay-sync-modal-description"
    });
    let trustPermanently = false;
    const trustSetting = new import_obsidian.Setting(contentEl).setName("\u0414\u043E\u0432\u0435\u0440\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u043E\u044F\u043D\u043D\u043E").setDesc("\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E \u0432 \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0434\u043B\u044F \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        trustPermanently = value;
      });
    });
    const buttonContainer = contentEl.createDiv({
      cls: "relay-sync-modal-buttons"
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("\u041E\u0442\u043A\u043B\u043E\u043D\u0438\u0442\u044C").onClick(() => {
      if (requestId) {
        this.onDecline(requestId);
      }
      this.close();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("\u041F\u0440\u0438\u043D\u044F\u0442\u044C").setCta().onClick(() => {
      if (requestId) {
        this.onAccept(requestId, trustPermanently);
      }
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RelaySyncSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a, _b, _c, _d;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Relay Sync" });
    containerEl.createEl("h3", { text: "\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435" });
    const serverSetting = new import_obsidian.Setting(containerEl).setName("\u0421\u0435\u0440\u0432\u0435\u0440 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D\u043D\u044B\u0439 \u0441\u0435\u0440\u0432\u0435\u0440 \u0438\u043B\u0438 \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u0441\u0432\u043E\u0439");
    const radioContainer = serverSetting.controlEl.createDiv({
      cls: "relay-sync-server-selection"
    });
    const defaultServerContainer = radioContainer.createDiv({
      cls: "relay-sync-radio-option"
    });
    const defaultServerRadio = defaultServerContainer.createEl("input", {
      attr: {
        type: "radio",
        name: "server-type",
        id: "default-server",
        value: "default"
      }
    });
    defaultServerContainer.createEl("label", {
      text: "\u0421\u0435\u0440\u0432\u0435\u0440 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E (ws://176.53.161.220:8080/ws)",
      attr: {
        for: "default-server"
      }
    });
    const customServerContainer = radioContainer.createDiv({
      cls: "relay-sync-radio-option"
    });
    const customServerRadio = customServerContainer.createEl("input", {
      attr: {
        type: "radio",
        name: "server-type",
        id: "custom-server",
        value: "custom"
      }
    });
    customServerContainer.createEl("label", {
      text: "\u0421\u0432\u043E\u0439 \u0441\u0435\u0440\u0432\u0435\u0440",
      attr: {
        for: "custom-server"
      }
    });
    const customUrlContainer = serverSetting.controlEl.createDiv({
      cls: "relay-sync-custom-url-container"
    });
    const customUrlInput = new import_obsidian.TextComponent(customUrlContainer).setPlaceholder("wss://your-relay-server.com").setValue(this.plugin.settings.serverUrl !== "ws://176.53.161.220:8080/ws" ? this.plugin.settings.serverUrl : "");
    if (this.plugin.settings.serverUrl === "ws://176.53.161.220:8080/ws" || !this.plugin.settings.serverUrl) {
      defaultServerRadio.checked = true;
      customUrlContainer.style.display = "none";
    } else {
      customServerRadio.checked = true;
      customUrlContainer.style.display = "block";
    }
    defaultServerRadio.addEventListener("change", async () => {
      if (defaultServerRadio.checked) {
        customUrlContainer.style.display = "none";
        this.plugin.settings.serverUrl = "ws://176.53.161.220:8080/ws";
        await this.plugin.saveSettings();
      }
    });
    customServerRadio.addEventListener("change", async () => {
      if (customServerRadio.checked) {
        customUrlContainer.style.display = "block";
        this.plugin.settings.serverUrl = customUrlInput.getValue() || "";
        await this.plugin.saveSettings();
      }
    });
    customUrlInput.onChange(async (value) => {
      if (customServerRadio.checked) {
        this.plugin.settings.serverUrl = value;
        await this.plugin.saveSettings();
      }
    });
    new import_obsidian.Setting(containerEl).setName("\u041F\u0430\u0440\u043E\u043B\u044C \u0448\u0438\u0444\u0440\u043E\u0432\u0430\u043D\u0438\u044F").setDesc("\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0434\u043B\u044F \u0448\u0438\u0444\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445. \u0414\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043E\u0434\u0438\u043D\u0430\u043A\u043E\u0432\u044B\u043C \u043D\u0430 \u0432\u0441\u0435\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u0445.").addText(
      (text) => text.setPlaceholder("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0434\u0435\u0436\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C").setValue(this.plugin.settings.encryptionPassword).onChange(async (value) => {
        this.plugin.settings.encryptionPassword = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0418\u043C\u044F \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430").setDesc("\u0418\u043C\u044F \u044D\u0442\u043E\u0433\u043E \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430, \u043A\u043E\u0442\u043E\u0440\u043E\u0435 \u0431\u0443\u0434\u0443\u0442 \u0432\u0438\u0434\u0435\u0442\u044C \u0434\u0440\u0443\u0433\u0438\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0438").addText(
      (text) => text.setPlaceholder("\u041C\u043E\u0439 \u043D\u043E\u0443\u0442\u0431\u0443\u043A").setValue(DeviceManager.getDeviceName()).onChange(async (value) => {
        DeviceManager.setDeviceName(value);
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u043E\u043B\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438").setDesc("\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u0432 \u043C\u0438\u043D\u0443\u0442\u0430\u0445 \u043C\u0435\u0436\u0434\u0443 \u043F\u043E\u043B\u043D\u044B\u043C\u0438 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F\u043C\u0438 (0 \u0434\u043B\u044F \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F)").addText(
      (text) => text.setPlaceholder("30").setValue(String(Math.floor(this.plugin.settings.fullSyncInterval / 6e4) || 0)).onChange(async (value) => {
        const minutes = parseInt(value) || 0;
        this.plugin.settings.fullSyncInterval = minutes * 6e4;
        await this.plugin.saveSettings();
        this.plugin.updateSyncOptions();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0430\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u043F\u0440\u0438 \u0437\u0430\u043F\u0443\u0441\u043A\u0435 Obsidian").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoConnect).onChange(async (value) => {
        this.plugin.settings.autoConnect = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`\u0410\u0432\u0442\u043E\u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 ${value ? "\u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E" : "\u0432\u044B\u043A\u043B\u044E\u0447\u0435\u043D\u043E"}`);
      })
    );
    containerEl.createEl("h3", { text: "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F" });
    const statusSetting = new import_obsidian.Setting(containerEl).setName("\u0421\u0442\u0430\u0442\u0443\u0441").setDesc("\u0421\u0442\u0430\u0442\u0443\u0441 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
    const statusIndicator = statusSetting.controlEl.createDiv({ cls: "relay-sync-status" });
    const statusDot = statusIndicator.createDiv({ cls: "relay-sync-status-indicator" });
    const statusText = statusIndicator.createSpan();
    if ((_a = this.plugin.syncManager) == null ? void 0 : _a.isConnected()) {
      statusDot.addClass("relay-sync-status-online");
      statusText.textContent = "\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E";
    } else {
      statusDot.addClass("relay-sync-status-offline");
      statusText.textContent = "\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E";
    }
    const connectionSetting = new import_obsidian.Setting(containerEl).setName("\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435\u043C").setDesc("\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u0438\u043B\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043E\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430");
    const connectButton = new import_obsidian.ButtonComponent(connectionSetting.controlEl).setCta().onClick(async () => {
      var _a2;
      if ((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.isConnected()) {
        this.plugin.stopSync();
        connectButton.setButtonText("\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F");
        statusDot.removeClass("relay-sync-status-online");
        statusDot.addClass("relay-sync-status-offline");
        statusText.textContent = "\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E";
      } else {
        await this.plugin.startSync();
        connectButton.setButtonText("\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F");
        statusDot.removeClass("relay-sync-status-offline");
        statusDot.addClass("relay-sync-status-online");
        statusText.textContent = "\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E";
      }
    });
    connectButton.setButtonText(
      ((_b = this.plugin.syncManager) == null ? void 0 : _b.isConnected()) ? "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F" : "\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F"
    );
    new import_obsidian.Setting(containerEl).setName("\u041F\u043E\u043B\u043D\u0430\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F").setDesc("\u041F\u0440\u0438\u043D\u0443\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432\u0441\u0435 \u0444\u0430\u0439\u043B\u044B").addButton(
      (button) => button.setButtonText("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C").onClick(async () => {
        var _a2;
        if (!((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.isConnected())) {
          new import_obsidian.Notice("\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
          return;
        }
        button.setButtonText("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F...");
        button.setDisabled(true);
        try {
          new import_obsidian.Notice("\u041D\u0430\u0447\u0430\u0442\u0430 \u043F\u043E\u043B\u043D\u0430\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F...");
          await this.plugin.syncManager.forceFullSync();
        } catch (error) {
          console.error("Error during force sync:", error);
          new import_obsidian.Notice(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: ${error.message}`);
        } finally {
          button.setButtonText("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C");
          button.setDisabled(false);
        }
      })
    );
    containerEl.createEl("h3", { text: "\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432" });
    const invitationKeySetting = new import_obsidian.Setting(containerEl).setName("\u041A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F").setDesc("\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043A\u043B\u044E\u0447 \u0434\u043B\u044F \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u0434\u0440\u0443\u0433\u043E\u0433\u043E \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430");
    let keyElement = null;
    invitationKeySetting.addButton((button) => button.setButtonText("\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043A\u043B\u044E\u0447").onClick(async () => {
      var _a2;
      if (!((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.isConnected())) {
        new import_obsidian.Notice("\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
        return;
      }
      try {
        if (keyElement) {
          keyElement.remove();
          keyElement = null;
        }
        const key = await this.plugin.syncManager.generateInvitationKey();
        keyElement = containerEl.createDiv({ cls: "relay-sync-key" });
        keyElement.textContent = key;
        const copyButton = keyElement.createEl("button", {
          text: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
          cls: "relay-sync-copy-button"
        });
        copyButton.addEventListener("click", () => {
          navigator.clipboard.writeText(key).then(() => {
            new import_obsidian.Notice("\u041A\u043B\u044E\u0447 \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430");
          });
        });
        setTimeout(() => {
          if (keyElement) {
            keyElement.remove();
            keyElement = null;
          }
        }, 10 * 60 * 1e3);
        new import_obsidian.Notice("\u041A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F \u0441\u043E\u0437\u0434\u0430\u043D (\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D 10 \u043C\u0438\u043D\u0443\u0442)");
      } catch (error) {
        console.error("Error generating invitation key:", error);
        new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u043A\u043B\u044E\u0447\u0430: " + error.message);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443").setDesc("\u0412\u0432\u0435\u0441\u0442\u0438 \u043A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F \u043E\u0442 \u0434\u0440\u0443\u0433\u043E\u0433\u043E \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430").addButton(
      (button) => button.setButtonText("\u0412\u0432\u0435\u0441\u0442\u0438 \u043A\u043B\u044E\u0447").onClick(() => {
        var _a2;
        if (!((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.isConnected())) {
          new import_obsidian.Notice("\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
          return;
        }
        new KeyInputModal(this.app, {
          onSubmit: async (key) => {
            var _a3;
            try {
              const success = await ((_a3 = this.plugin.syncManager) == null ? void 0 : _a3.useInvitationKey(key));
              if (success) {
                new import_obsidian.Notice("\u0417\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D. \u041E\u0436\u0438\u0434\u0430\u0439\u0442\u0435 \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u044F.");
              } else {
                new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043A\u043B\u044E\u0447 \u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.");
              }
            } catch (error) {
              console.error("Error using invitation key:", error);
              new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0438 \u043A\u043B\u044E\u0447\u0430: " + error.message);
            }
          },
          onClose: () => {
          }
        }).open();
      })
    );
    const pendingRequests = ((_c = this.plugin.syncManager) == null ? void 0 : _c.getPendingSyncRequests()) || [];
    if (pendingRequests.length > 0) {
      containerEl.createEl("h3", { text: "\u041E\u0436\u0438\u0434\u0430\u044E\u0449\u0438\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B" });
      for (const request of pendingRequests) {
        if (!request.requestId || !request.sourceDeviceId)
          continue;
        new import_obsidian.Setting(containerEl).setName(`\u0417\u0430\u043F\u0440\u043E\u0441 \u043E\u0442 ${request.deviceName || "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E\u0433\u043E \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430"}`).setDesc("\u0417\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E").addButton(
          (button) => button.setButtonText("\u041F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C").onClick(() => {
            new SyncRequestModal(
              this.app,
              request,
              async (requestId, trust) => {
                var _a2;
                try {
                  new import_obsidian.Notice("\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
                  const success = await ((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.respondToSyncRequest(
                    requestId,
                    true,
                    trust
                  ));
                  if (success) {
                    new import_obsidian.Notice("\u0417\u0430\u043F\u0440\u043E\u0441 \u043F\u0440\u0438\u043D\u044F\u0442! \u0423\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E \u0432 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0435.");
                    setTimeout(() => {
                      this.display();
                    }, 1e3);
                  } else {
                    new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u0438\u043D\u044F\u0442\u0438\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0430");
                  }
                } catch (error) {
                  console.error("Error accepting sync request:", error);
                  new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u0438\u043D\u044F\u0442\u0438\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0430: " + error.message);
                }
              },
              async (requestId) => {
                var _a2;
                try {
                  new import_obsidian.Notice("\u041E\u0442\u043A\u043B\u043E\u043D\u0435\u043D\u0438\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
                  const success = await ((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.respondToSyncRequest(
                    requestId,
                    false,
                    false
                  ));
                  if (success) {
                    new import_obsidian.Notice("\u0417\u0430\u043F\u0440\u043E\u0441 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u043A\u043B\u043E\u043D\u0435\u043D");
                    setTimeout(() => {
                      this.display();
                    }, 1e3);
                  } else {
                    new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u043B\u043E\u043D\u0435\u043D\u0438\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0430");
                  }
                } catch (error) {
                  console.error("Error declining sync request:", error);
                  new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u043B\u043E\u043D\u0435\u043D\u0438\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0430: " + error.message);
                }
              }
            ).open();
          })
        );
      }
    }
    containerEl.createEl("h3", { text: "\u0414\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0435 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430" });
    const trustedDevices = ((_d = this.plugin.syncManager) == null ? void 0 : _d.getTrustedDevices()) || [];
    if (trustedDevices.length === 0) {
      containerEl.createEl("p", {
        text: "\u041D\u0435\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u0435\u0441\u044C \u043A \u0434\u0440\u0443\u0433\u043E\u043C\u0443 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 \u0438\u043B\u0438 \u043F\u0440\u0438\u043C\u0438\u0442\u0435 \u0437\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E.",
        cls: "relay-sync-empty-list"
      });
    } else {
      const deviceList = containerEl.createDiv({ cls: "relay-sync-device-list" });
      for (const device of trustedDevices) {
        const deviceItem = deviceList.createDiv({ cls: "relay-sync-device-item" });
        const deviceInfo = deviceItem.createDiv({ cls: "relay-sync-device-info" });
        deviceInfo.createDiv({ text: device.name, cls: "relay-sync-device-name" });
        deviceInfo.createDiv({ text: `ID: ${device.id}`, cls: "relay-sync-device-id" });
        const actionButtons = deviceItem.createDiv({ cls: "relay-sync-device-actions" });
        const revokeButton = actionButtons.createEl("button", {
          text: "\u041E\u0442\u043E\u0437\u0432\u0430\u0442\u044C \u0434\u043E\u0432\u0435\u0440\u0438\u0435",
          cls: "relay-sync-revoke-button"
        });
        revokeButton.addEventListener("click", async () => {
          var _a2;
          try {
            const success = await ((_a2 = this.plugin.syncManager) == null ? void 0 : _a2.revokeTrust(device.id));
            if (success) {
              new import_obsidian.Notice(`\u0414\u043E\u0432\u0435\u0440\u0438\u0435 \u043A \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 ${device.name} \u043E\u0442\u043E\u0437\u0432\u0430\u043D\u043E`);
              this.display();
            } else {
              new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u0437\u044B\u0432\u0435 \u0434\u043E\u0432\u0435\u0440\u0438\u044F");
            }
          } catch (error) {
            console.error("Error revoking trust:", error);
            new import_obsidian.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u0437\u044B\u0432\u0435 \u0434\u043E\u0432\u0435\u0440\u0438\u044F: " + error.message);
          }
        });
      }
    }
    containerEl.createEl("h3", { text: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F" });
    const ignoredPathsSetting = new import_obsidian.Setting(containerEl).setName("\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0443\u0442\u0438").setDesc("\u041F\u0443\u0442\u0438, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0431\u0443\u0434\u0443\u0442 \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u044B \u0438\u0437 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 (\u043F\u043E \u043E\u0434\u043D\u043E\u043C\u0443 \u043D\u0430 \u0441\u0442\u0440\u043E\u043A\u0443)");
    const ignoredPathsField = ignoredPathsSetting.controlEl.createEl("textarea", {
      cls: "relay-sync-ignored-paths",
      attr: {
        rows: "5"
      }
    });
    ignoredPathsField.value = (this.plugin.settings.ignoredPaths || []).join("\n");
    ignoredPathsField.addEventListener("change", async () => {
      const paths = ignoredPathsField.value.split("\n").map((path) => path.trim()).filter((path) => path.length > 0);
      this.plugin.settings.ignoredPaths = paths;
      await this.plugin.saveSettings();
      this.plugin.updateSyncOptions();
    });
  }
};

// src/ui/status-bar.ts
var import_obsidian2 = require("obsidian");
var StatusBarItem = class {
  constructor(statusBarEl) {
    this.status = "disconnected" /* DISCONNECTED */;
    this.syncingAnimationInterval = null;
    this.dots = 0;
    this.stats = {};
    this.showDetailedStatus = true;
    this.statusBarEl = statusBarEl;
    this.statusBarEl.classList.add("relay-sync-statusbar");
    this.statusBarEl.addEventListener("click", this.toggleDetailedStatus.bind(this));
    this.render();
  }
  /**
   * Обновить статус синхронизации
   */
  setStatus(status, stats) {
    const statusChanged = this.status !== status;
    this.status = status;
    if (stats) {
      this.stats = { ...this.stats, ...stats };
    }
    if (statusChanged && this.syncingAnimationInterval) {
      clearInterval(this.syncingAnimationInterval);
      this.syncingAnimationInterval = null;
    }
    if (status === "syncing" /* SYNCING */ && statusChanged) {
      this.startSyncingAnimation();
    }
    this.render();
  }
  /**
   * Переключить режим отображения подробной информации
   */
  toggleDetailedStatus() {
    this.showDetailedStatus = !this.showDetailedStatus;
    this.render();
  }
  /**
   * Форматировать время в относительном формате
   */
  formatTime(timestamp) {
    return (0, import_obsidian2.moment)(timestamp).fromNow();
  }
  /**
   * Отрендерить компонент статусной строки
   */
  render() {
    this.statusBarEl.empty();
    const iconContainer = this.statusBarEl.createSpan({
      cls: "relay-sync-statusbar-icon"
    });
    const textContainer = this.statusBarEl.createSpan({
      cls: "relay-sync-statusbar-text"
    });
    const detailsContainer = this.statusBarEl.createDiv({
      cls: "relay-sync-statusbar-details"
    });
    detailsContainer.style.display = this.showDetailedStatus ? "flex" : "none";
    switch (this.status) {
      case "connected" /* CONNECTED */:
        (0, import_obsidian2.setIcon)(iconContainer, "cloud");
        iconContainer.classList.add("relay-sync-statusbar-connected");
        textContainer.textContent = "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F: \u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E";
        let connectedTooltip = "\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438";
        if (this.stats.lastSyncTime) {
          connectedTooltip += `
\u041F\u043E\u0441\u043B\u0435\u0434\u043D\u044F\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F: ${this.formatTime(this.stats.lastSyncTime)}`;
        }
        if (this.stats.trustedDevices !== void 0) {
          connectedTooltip += `
\u0414\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432: ${this.stats.trustedDevices}`;
        }
        if (this.stats.filesTotal !== void 0) {
          connectedTooltip += `
\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E \u0444\u0430\u0439\u043B\u043E\u0432: ${this.stats.filesTotal}`;
        }
        this.statusBarEl.title = connectedTooltip;
        break;
      case "disconnected" /* DISCONNECTED */:
        (0, import_obsidian2.setIcon)(iconContainer, "cloud-off");
        iconContainer.classList.add("relay-sync-statusbar-disconnected");
        textContainer.textContent = "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F: \u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E";
        this.statusBarEl.title = "\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u043E\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438";
        break;
      case "syncing" /* SYNCING */:
        (0, import_obsidian2.setIcon)(iconContainer, "cloud-sync");
        iconContainer.classList.add("relay-sync-statusbar-syncing");
        textContainer.textContent = "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F...";
        let syncingTooltip = "\u0412\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F";
        if (this.stats.syncProgress !== void 0) {
          syncingTooltip += `
\u041F\u0440\u043E\u0433\u0440\u0435\u0441\u0441: ${this.stats.syncProgress}%`;
        }
        if (this.stats.filesChanged !== void 0) {
          syncingTooltip += `
\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u0443\u0435\u0442\u0441\u044F \u0444\u0430\u0439\u043B\u043E\u0432: ${this.stats.filesChanged}`;
        }
        this.statusBarEl.title = syncingTooltip;
        break;
      case "error" /* ERROR */:
        (0, import_obsidian2.setIcon)(iconContainer, "alert-triangle");
        iconContainer.classList.add("relay-sync-statusbar-error");
        textContainer.textContent = "\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F: \u041E\u0448\u0438\u0431\u043A\u0430";
        let errorTooltip = "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438";
        if (this.stats.errorMessage) {
          errorTooltip += `
${this.stats.errorMessage}`;
        }
        this.statusBarEl.title = errorTooltip;
        break;
    }
    if (this.showDetailedStatus) {
      if (this.stats.lastSyncTime) {
        const lastSyncEl = detailsContainer.createDiv({
          cls: "relay-sync-detail-item"
        });
        (0, import_obsidian2.setIcon)(lastSyncEl.createSpan(), "clock");
        lastSyncEl.createSpan({
          text: this.formatTime(this.stats.lastSyncTime)
        });
      }
      if (this.stats.trustedDevices !== void 0) {
        const devicesEl = detailsContainer.createDiv({
          cls: "relay-sync-detail-item"
        });
        (0, import_obsidian2.setIcon)(devicesEl.createSpan(), "devices");
        devicesEl.createSpan({
          text: `${this.stats.trustedDevices}`
        });
      }
      if (this.status === "syncing" /* SYNCING */ && this.stats.syncProgress !== void 0) {
        const progressEl = detailsContainer.createDiv({
          cls: "relay-sync-detail-item"
        });
        (0, import_obsidian2.setIcon)(progressEl.createSpan(), "percent");
        progressEl.createSpan({
          text: `${this.stats.syncProgress}%`
        });
      }
    }
  }
  /**
   * Запустить анимацию синхронизации
   */
  startSyncingAnimation() {
    this.dots = 0;
    this.syncingAnimationInterval = setInterval(() => {
      this.dots = (this.dots + 1) % 4;
      const dotsText = ".".repeat(this.dots);
      const textContainer = this.statusBarEl.querySelector(".relay-sync-statusbar-text");
      if (textContainer) {
        textContainer.textContent = `\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F${dotsText}`;
      }
    }, 500);
  }
};

// src/client/sync-manager.ts
var import_obsidian4 = require("obsidian");

// src/client/relay-client.ts
var RelayClient = class {
  constructor(options) {
    this.ws = null;
    this.isConnected = false;
    this.reconnectTimeout = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 10;
    this.heartbeatInterval = null;
    this.messageCallbacks = /* @__PURE__ */ new Map();
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.trustedDevices = [];
    // Сохраняем оригинальный обработчик для генерации ключа
    this.onMessageCallbackOriginal = () => {
    };
    this.serverUrl = options.serverUrl;
    this.deviceId = options.deviceId;
    this.deviceName = options.deviceName;
    this.onMessageCallback = options.onMessage;
    this.onConnectionChangeCallback = options.onConnectionChange;
    this.onTrustedDevicesChangeCallback = options.onTrustedDevicesChange;
    this.onSyncRequestCallback = options.onSyncRequest;
  }
  /**
   * Подключиться к серверу
   */
  connect() {
    if (this.ws && (this.ws.readyState === WebSocket.CONNECTING || this.ws.readyState === WebSocket.OPEN)) {
      console.log("WebSocket already connected or connecting");
      return;
    }
    try {
      this.ws = new WebSocket(this.serverUrl);
      this.ws.onopen = this.handleOpen.bind(this);
      this.ws.onmessage = this.handleMessage.bind(this);
      this.ws.onclose = this.handleClose.bind(this);
      this.ws.onerror = this.handleError.bind(this);
    } catch (error) {
      console.error("Error connecting to WebSocket server:", error);
      this.scheduleReconnect();
    }
  }
  /**
   * Отключиться от сервера
   */
  disconnect() {
    this.stopHeartbeat();
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Отправить сообщение на сервер
   */
  sendMessage(message) {
    if (!this.isConnected || !this.ws) {
      console.error("Cannot send message: WebSocket not connected");
      if (!this.reconnectTimeout) {
        console.log("\u041F\u043E\u043F\u044B\u0442\u043A\u0430 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438...");
        this.scheduleReconnect();
      }
      return false;
    }
    if (this.ws.readyState !== WebSocket.OPEN) {
      console.error(`Cannot send message: WebSocket \u0432 \u043D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u043C \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0438 (${this.ws.readyState})`);
      this.disconnect();
      this.connect();
      return false;
    }
    try {
      const fullMessage = {
        ...message,
        sourceDeviceId: this.deviceId,
        timestamp: Date.now()
      };
      console.log("\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F:", fullMessage);
      this.ws.send(JSON.stringify(fullMessage));
      console.log("\u0421\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E \u0443\u0441\u043F\u0435\u0448\u043D\u043E");
      return true;
    } catch (error) {
      console.error("Error sending message:", error);
      return false;
    }
  }
  /**
   * Отправить сообщение и получить ответ через Promise
   */
  async sendMessageWithResponse(message, timeout = 3e4) {
    return new Promise((resolve, reject) => {
      if (!this.isConnected || !this.ws) {
        reject(new Error("WebSocket not connected"));
        return;
      }
      const requestId = this.generateRequestId();
      const fullMessage = {
        ...message,
        sourceDeviceId: this.deviceId,
        requestId,
        timestamp: Date.now()
      };
      console.log("\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0441 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u0435\u043C \u043E\u0442\u0432\u0435\u0442\u0430:", fullMessage);
      const timeoutId = setTimeout(() => {
        console.log("\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0434\u043B\u044F \u0437\u0430\u043F\u0440\u043E\u0441\u0430:", requestId);
        this.messageCallbacks.delete(requestId);
        reject(new Error("Request timeout"));
      }, timeout);
      this.messageCallbacks.set(requestId, (response) => {
        console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043E\u0442\u0432\u0435\u0442 \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441:", requestId, response);
        clearTimeout(timeoutId);
        resolve(response);
      });
      try {
        this.ws.send(JSON.stringify(fullMessage));
        console.log("\u0421\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E \u0443\u0441\u043F\u0435\u0448\u043D\u043E, \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u0435 \u043E\u0442\u0432\u0435\u0442\u0430...");
      } catch (error) {
        console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F:", error);
        clearTimeout(timeoutId);
        this.messageCallbacks.delete(requestId);
        reject(error);
      }
    });
  }
  /**
   * Генерация ключа приглашения
   */
  async generateInvitationKey(expirationMinutes = 10) {
    try {
      return new Promise((resolve, reject) => {
        const keyHandler = (message) => {
          if (message.type === "invitationKey" && message.key) {
            console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F:", message.key);
            this.onMessageCallback = this.onMessageCallbackOriginal;
            resolve(message.key);
          }
        };
        this.onMessageCallbackOriginal = this.onMessageCallback;
        const tempHandler = (message) => {
          if (message.type === "invitationKey") {
            keyHandler(message);
          } else {
            this.onMessageCallbackOriginal(message);
          }
        };
        this.onMessageCallback = tempHandler;
        this.sendMessage({
          type: "generateInvitationKey",
          payload: {
            expiration: expirationMinutes * 60 * 1e3
          }
        });
        setTimeout(() => {
          this.onMessageCallback = this.onMessageCallbackOriginal;
          reject(new Error("\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043A\u043B\u044E\u0447\u0430 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F"));
        }, 3e4);
      });
    } catch (error) {
      console.error("Error generating invitation key:", error);
      throw error;
    }
  }
  // Этот обработчик уже определен выше в классе
  /**
   * Использование ключа приглашения
   */
  async useInvitationKey(key) {
    try {
      if (!key || key.trim() === "") {
        console.error("Error: Empty invitation key");
        return false;
      }
      return new Promise((resolve, reject) => {
        const syncRequestHandler = (message) => {
          if (message.type === "syncRequestSent") {
            console.log("\u0417\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D");
            this.onMessageCallback = this.onMessageCallbackOriginal;
            resolve(true);
          } else if (message.type === "error") {
            console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0438 \u043A\u043B\u044E\u0447\u0430:", message);
            this.onMessageCallback = this.onMessageCallbackOriginal;
            resolve(false);
          }
        };
        this.onMessageCallbackOriginal = this.onMessageCallback;
        const tempHandler = (message) => {
          if (message.type === "syncRequestSent" || message.type === "error") {
            syncRequestHandler(message);
          } else {
            this.onMessageCallbackOriginal(message);
          }
        };
        this.onMessageCallback = tempHandler;
        const cleanKey = key.trim().toUpperCase();
        console.log("Sending cleaned key:", cleanKey);
        this.sendMessage({
          type: "useInvitationKey",
          key: cleanKey,
          deviceName: this.deviceName
        });
        setTimeout(() => {
          this.onMessageCallback = this.onMessageCallbackOriginal;
          reject(new Error("\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u043F\u0440\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0438 \u043A\u043B\u044E\u0447\u0430 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F"));
        }, 3e4);
      });
    } catch (error) {
      console.error("Error using invitation key:", error);
      return false;
    }
  }
  /**
   * Ответ на запрос синхронизации
   */
  async respondToSyncRequest(requestId, targetDeviceId, accept, trusted = false) {
    try {
      console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u043E\u0442\u0432\u0435\u0442\u0430 \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: 
                requestId=${requestId}, 
                targetDeviceId=${targetDeviceId}, 
                accept=${accept}, 
                trusted=${trusted}`);
      this.sendMessage({
        type: "syncResponse",
        requestId,
        targetDeviceId,
        accept,
        trusted: trusted || false
      });
      console.log("\u0421\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u0441 \u043E\u0442\u0432\u0435\u0442\u043E\u043C \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E");
      if (accept && trusted) {
        console.log(`\u041B\u043E\u043A\u0430\u043B\u044C\u043D\u043E \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u043C \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E ${targetDeviceId} \u0432 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0435`);
        if (!this.trustedDevices) {
          this.trustedDevices = [];
        }
        let existingDevice = false;
        if (Array.isArray(this.trustedDevices)) {
          existingDevice = this.trustedDevices.some((device) => device.id === targetDeviceId);
        }
        if (!existingDevice) {
          const newDevice = {
            id: targetDeviceId,
            name: "\u041D\u043E\u0432\u043E\u0435 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E"
            // Имя обновится позже от сервера
          };
          this.trustedDevices = [...this.trustedDevices, newDevice];
          this.onTrustedDevicesChangeCallback(this.trustedDevices);
          console.log("\u0421\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E");
        }
      }
      return true;
    } catch (error) {
      console.error("Error responding to sync request:", error);
      return false;
    }
  }
  /**
   * Отзыв доверия устройству
   */
  async revokeTrust(deviceId) {
    try {
      const response = await this.sendMessageWithResponse({
        type: "revokeTrust",
        targetDeviceId: deviceId
      });
      if (response.success) {
        this.trustedDevices = this.trustedDevices.filter((device) => device.id !== deviceId);
        this.onTrustedDevicesChangeCallback(this.trustedDevices);
      }
      return response.success;
    } catch (error) {
      console.error("Error revoking trust:", error);
      return false;
    }
  }
  /**
   * Обработчик успешного подключения
   */
  handleOpen() {
    console.log("WebSocket connected");
    this.isConnected = true;
    this.reconnectAttempts = 0;
    this.onConnectionChangeCallback(true);
    this.registerDevice();
    this.startHeartbeat();
  }
  /**
   * Регистрация устройства на сервере
   */
  registerDevice() {
    this.sendMessage({
      type: "register",
      deviceName: this.deviceName
    });
    this.requestTrustedDevices();
  }
  /**
   * Запрос списка доверенных устройств
   */
  requestTrustedDevices() {
    console.log("\u0417\u0430\u043F\u0440\u043E\u0441 \u0441\u043F\u0438\u0441\u043A\u0430 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432");
    this.sendMessage({
      type: "getTrustedDevices"
    });
    if (!this.trustedDevices || !Array.isArray(this.trustedDevices)) {
      this.trustedDevices = [];
    }
  }
  /**
   * Обработчик получения сообщения
   */
  handleMessage(event) {
    try {
      const message = JSON.parse(event.data);
      console.log("Received WebSocket message:", message);
      if (message.requestId && this.messageCallbacks.has(message.requestId)) {
        console.log("\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0442\u0432\u0435\u0442\u0430 \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441:", message.requestId);
        const callback = this.messageCallbacks.get(message.requestId);
        this.messageCallbacks.delete(message.requestId);
        if (callback)
          callback(message);
        return;
      }
      switch (message.type) {
        case "pong":
          break;
        case "invitationKey":
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F:", message.key);
          this.onMessageCallback(message);
          break;
        case "trustedDevices":
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432");
          if (message.devices && Array.isArray(message.devices)) {
            this.handleTrustedDevicesUpdate(message.devices);
          } else if (message.payload) {
            this.handleTrustedDevicesUpdate(message.payload);
          } else {
            this.handleTrustedDevicesUpdate([]);
          }
          break;
        case "syncRequest":
          console.log(
            "\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u0437\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430:",
            message.sourceName || message.sourceDeviceId
          );
          this.handleSyncRequest(message);
          break;
        case "syncResponseReceived":
          console.log(
            "\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043E\u0442\u0432\u0435\u0442 \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438:",
            message.accepted ? "\u041F\u0420\u0418\u041D\u042F\u0422" : "\u041E\u0422\u041A\u041B\u041E\u041D\u0415\u041D"
          );
          if (message.accepted && message.sourceDeviceId) {
            console.log("\u0417\u0430\u043F\u0440\u043E\u0441 \u043F\u0440\u0438\u043D\u044F\u0442, \u043E\u0431\u043D\u043E\u0432\u043B\u044F\u0435\u043C \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432");
            if (!this.trustedDevices) {
              this.trustedDevices = [];
            }
            let existingIndex = -1;
            if (Array.isArray(this.trustedDevices)) {
              existingIndex = this.trustedDevices.findIndex(
                (d) => d && d.id === message.sourceDeviceId
              );
            }
            if (existingIndex === -1) {
              this.trustedDevices.push({
                id: message.sourceDeviceId,
                name: message.deviceName || "\u0423\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E " + message.sourceDeviceId.substring(0, 8)
              });
              this.onTrustedDevicesChangeCallback(this.trustedDevices);
              console.log("\u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E \u043D\u043E\u0432\u043E\u0435 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u043E\u0435 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E:", message.sourceDeviceId);
            }
          }
          this.onMessageCallback(message);
          break;
        case "trustRevoked":
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u043E \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u0435 \u043E\u0431 \u043E\u0442\u0437\u044B\u0432\u0435 \u0434\u043E\u0432\u0435\u0440\u0438\u044F");
          this.handleTrustRevoked(message);
          break;
        case "trustExpired":
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u043E \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u0435 \u043E\u0431 \u0438\u0441\u0442\u0435\u0447\u0435\u043D\u0438\u0438 \u0441\u0440\u043E\u043A\u0430 \u0434\u043E\u0432\u0435\u0440\u0438\u044F");
          this.handleTrustExpired(message);
          break;
        case "message":
          if (message.payload) {
            const payload = message.payload;
            if (typeof payload === "object" && payload !== null && ("path" in payload || "encryptedData" in payload || "deleted" in payload)) {
              console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u043E\u0432\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 (\u0442\u0438\u043F message)");
              const fileSyncMessage = {
                ...message,
                type: "fileSync"
              };
              this.onMessageCallback(fileSyncMessage);
              break;
            }
          }
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u043E \u043E\u0431\u044B\u0447\u043D\u043E\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u0441 \u0434\u0430\u043D\u043D\u044B\u043C\u0438");
          this.onMessageCallback(message);
          break;
        case "error":
          console.error("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043E\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430:", message.message);
          this.onMessageCallback(message);
          break;
        default:
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u043E \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0435 \u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E\u0433\u043E \u0442\u0438\u043F\u0430:", message.type);
          this.onMessageCallback(message);
          break;
      }
    } catch (error) {
      console.error("Error parsing message:", error);
    }
  }
  /**
   * Обработка обновления списка доверенных устройств
   */
  handleTrustedDevicesUpdate(devices) {
    console.log("\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u043F\u0438\u0441\u043A\u0430 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432:", devices);
    if (!devices) {
      console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043F\u0443\u0441\u0442\u043E\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432, \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u0443\u0435\u043C \u043F\u0443\u0441\u0442\u043E\u0439 \u043C\u0430\u0441\u0441\u0438\u0432");
      this.trustedDevices = [];
      this.onTrustedDevicesChangeCallback([]);
      return;
    }
    const validDevices = Array.isArray(devices) ? devices.filter((d) => d && typeof d === "object" && d.id) : [];
    console.log(`\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u043E ${validDevices.length} \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
    this.trustedDevices = validDevices;
    this.onTrustedDevicesChangeCallback(validDevices);
  }
  /**
   * Обработка запроса на синхронизацию
   */
  handleSyncRequest(request) {
    if (request.requestId) {
      this.pendingRequests.set(request.requestId, request);
    }
    this.onSyncRequestCallback(request);
  }
  /**
   * Обработка отзыва доверия
   */
  handleTrustRevoked(message) {
    if (message.sourceDeviceId) {
      this.trustedDevices = this.trustedDevices.filter(
        (device) => device.id !== message.sourceDeviceId
      );
      this.onTrustedDevicesChangeCallback(this.trustedDevices);
    }
  }
  /**
   * Обработка истечения срока доверия
   */
  handleTrustExpired(message) {
    if (message.sourceDeviceId) {
      this.trustedDevices = this.trustedDevices.filter(
        (device) => device.id !== message.sourceDeviceId
      );
      this.onTrustedDevicesChangeCallback(this.trustedDevices);
    }
  }
  /**
   * Обработчик закрытия соединения
   */
  handleClose(event) {
    console.log(`WebSocket disconnected with code: ${event.code}, reason: ${event.reason}`);
    this.isConnected = false;
    this.onConnectionChangeCallback(false);
    this.stopHeartbeat();
    if (this.ws) {
      this.scheduleReconnect();
    }
  }
  /**
   * Обработчик ошибки соединения
   */
  handleError(error) {
    console.error("WebSocket error:", error);
  }
  /**
   * Планирование переподключения
   */
  scheduleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.log("Maximum reconnect attempts reached");
      return;
    }
    const delay = Math.min(1e3 * Math.pow(2, this.reconnectAttempts), 3e4);
    this.reconnectAttempts++;
    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
    this.reconnectTimeout = setTimeout(() => {
      console.log("Attempting to reconnect...");
      this.connect();
    }, delay);
  }
  /**
   * Начать отправку пинг-сообщений
   */
  startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.sendMessage({ type: "ping" });
      }
    }, 3e4);
  }
  /**
   * Остановить отправку пинг-сообщений
   */
  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
  /**
   * Генерация уникального идентификатора запроса
   */
  generateRequestId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }
  /**
   * Получить список доверенных устройств
   */
  getTrustedDevices() {
    return [...this.trustedDevices];
  }
  /**
   * Проверить, является ли устройство доверенным
   */
  isDeviceTrusted(deviceId) {
    return this.trustedDevices.some((device) => device.id === deviceId);
  }
};

// src/utils/file-watcher.ts
var import_obsidian3 = require("obsidian");
var FileWatcher = class {
  constructor(vault, onChange) {
    this.ignoredPatterns = [
      /\.git\//,
      // Git-файлы
      /\.obsidian\//,
      // Настройки Obsidian
      /\.DS_Store/,
      // Служебные файлы macOS
      /Thumbs\.db/,
      // Служебные файлы Windows
      /\.sync\//,
      // Папка синхронизации
      /\.trash\//
      // Корзина
    ];
    this.ignoredExtensions = [
      ".tmp",
      ".temp",
      ".swp",
      ".bak"
    ];
    this.vault = vault;
    this.onChangeCallback = onChange;
  }
  /**
   * Запустить отслеживание изменений файлов
   */
  startWatching() {
    this.vault.on("create", this.handleFileCreate.bind(this));
    this.vault.on("modify", this.handleFileModify.bind(this));
    this.vault.on("delete", this.handleFileDelete.bind(this));
    this.vault.on("rename", this.handleFileRename.bind(this));
  }
  /**
   * Остановить отслеживание изменений файлов
   */
  stopWatching() {
    this.vault.off("create", this.handleFileCreate.bind(this));
    this.vault.off("modify", this.handleFileModify.bind(this));
    this.vault.off("delete", this.handleFileDelete.bind(this));
    this.vault.off("rename", this.handleFileRename.bind(this));
  }
  /**
   * Добавить паттерн для игнорирования файлов
   */
  addIgnorePattern(pattern) {
    this.ignoredPatterns.push(pattern);
  }
  /**
   * Добавить расширение для игнорирования файлов
   */
  addIgnoreExtension(extension) {
    this.ignoredExtensions.push(extension);
  }
  /**
   * Проверить, должен ли файл быть проигнорирован
   */
  shouldIgnore(path) {
    for (const pattern of this.ignoredPatterns) {
      if (pattern.test(path)) {
        return true;
      }
    }
    for (const ext of this.ignoredExtensions) {
      if (path.endsWith(ext)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Обработчик создания файла
   */
  handleFileCreate(file) {
    if (!(file instanceof import_obsidian3.TFile) || this.shouldIgnore(file.path)) {
      return;
    }
    this.onChangeCallback({
      path: file.path,
      type: "create",
      file,
      timestamp: Date.now()
    });
  }
  /**
   * Обработчик изменения файла
   */
  handleFileModify(file) {
    if (!(file instanceof import_obsidian3.TFile) || this.shouldIgnore(file.path)) {
      return;
    }
    this.onChangeCallback({
      path: file.path,
      type: "modify",
      file,
      timestamp: Date.now()
    });
  }
  /**
   * Обработчик удаления файла
   */
  handleFileDelete(file) {
    if (!(file instanceof import_obsidian3.TFile) || this.shouldIgnore(file.path)) {
      return;
    }
    this.onChangeCallback({
      path: file.path,
      type: "delete",
      file,
      timestamp: Date.now()
    });
  }
  /**
   * Обработчик переименования файла
   */
  handleFileRename(file, oldPath) {
    if (!(file instanceof import_obsidian3.TFile) || this.shouldIgnore(file.path)) {
      return;
    }
    this.onChangeCallback({
      path: file.path,
      oldPath,
      type: "rename",
      file,
      timestamp: Date.now()
    });
  }
  /**
   * Получить текущее состояние всех файлов
   */
  async scanAllFiles() {
    const files = this.vault.getFiles();
    const changes = [];
    for (const file of files) {
      if (this.shouldIgnore(file.path)) {
        continue;
      }
      changes.push({
        path: file.path,
        type: "create",
        // Используем 'create' как тип при сканировании
        file,
        timestamp: file.stat.mtime
        // Используем время модификации файла
      });
    }
    return changes;
  }
};

// src/client/sync-manager.ts
var SyncManager = class {
  constructor(app, options) {
    this.isSyncing = false;
    this.fullSyncInterval = null;
    this.pendingSyncRequests = /* @__PURE__ */ new Map();
    this.trustedDevices = [];
    // Режим ожидания - когда плагин запущен, но нет активных доверенных устройств
    this.waitingMode = true;
    // Счетчик изменений, ожидающих синхронизации
    this.pendingChangesCount = 0;
    /**
     * Сохранить содержимое файла в кэш
     */
    this.fileContentCache = /* @__PURE__ */ new Map();
    /**
     * Запросить метаданные файлов у других устройств для оптимизации синхронизации
     */
    this.deviceFileMetadata = /* @__PURE__ */ new Map();
    this.app = app;
    this.options = options;
    this.encryptionPassword = options.encryptionPassword;
    this.syncState = this.loadSyncState();
    this.relayClient = new RelayClient({
      serverUrl: options.serverUrl,
      deviceId: this.syncState.deviceId,
      deviceName: DeviceManager.getDeviceName(),
      onMessage: this.handleSyncMessage.bind(this),
      onConnectionChange: this.handleConnectionChange.bind(this),
      onTrustedDevicesChange: this.handleTrustedDevicesChange.bind(this),
      onSyncRequest: this.handleSyncRequest.bind(this)
    });
    this.fileWatcher = new FileWatcher(
      app.vault,
      this.handleFileChange.bind(this)
    );
    if (options.ignoredPaths) {
      for (const path of options.ignoredPaths) {
        this.fileWatcher.addIgnorePattern(new RegExp(path));
      }
    }
  }
  /**
   * Запустить процесс синхронизации
   */
  async start() {
    this.waitingMode = true;
    console.log("\u0417\u0430\u043F\u0443\u0441\u043A \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F...");
    this.relayClient.connect();
    this.fileWatcher.startWatching();
    await this.updateLocalFileState();
    setTimeout(async () => {
      console.log("\u041F\u0440\u043E\u0432\u0435\u0440\u043A\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E\u0441\u0442\u0438 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432...");
      await this.checkActiveTrustedDevices();
    }, 3e3);
  }
  /**
   * Проверка активных доверенных устройств и отправка сигнала
   */
  async checkActiveTrustedDevices() {
    const trustedDevices = this.relayClient.getTrustedDevices();
    if (!Array.isArray(trustedDevices) || trustedDevices.length === 0) {
      console.log("\u041D\u0435\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u041F\u0435\u0440\u0435\u0445\u043E\u0434 \u0432 \u0440\u0435\u0436\u0438\u043C \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F.");
      this.waitingMode = true;
      await this.updateLocalFileState();
      return;
    }
    console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0441\u0438\u0433\u043D\u0430\u043B\u0430 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u0438 \u043D\u0430 ${trustedDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432...`);
    const pingPromises = trustedDevices.map((device) => {
      return new Promise((resolve) => {
        const pingId = `ping-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        const handlePingResponse = (message) => {
          if (message.type === "message" && message.sourceDeviceId === device.id && message.payload && message.payload.action === "devicePingResponse" && message.payload.pingId === pingId) {
            console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043E\u0442\u0432\u0435\u0442 \u043D\u0430 \u043F\u0438\u043D\u0433 \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${device.name || device.id}`);
            const originalCallback2 = this.relayClient["onMessageCallbackOriginal"];
            if (originalCallback2) {
              this.relayClient["onMessageCallback"] = originalCallback2;
            }
            resolve(true);
          }
        };
        const originalCallback = this.relayClient["onMessageCallback"];
        this.relayClient["onMessageCallbackOriginal"] = originalCallback;
        this.relayClient["onMessageCallback"] = (message) => {
          handlePingResponse(message);
          originalCallback(message);
        };
        this.relayClient.sendMessage({
          type: "message",
          targetDeviceId: device.id,
          payload: {
            action: "devicePing",
            pingId
          }
        });
        setTimeout(() => {
          this.relayClient["onMessageCallback"] = originalCallback;
          resolve(false);
        }, 3e3);
      });
    });
    const results = await Promise.all(pingPromises);
    const activeDevicesCount = results.filter((r) => r).length;
    console.log(`\u0410\u043A\u0442\u0438\u0432\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 \u043E\u0431\u043D\u0430\u0440\u0443\u0436\u0435\u043D\u043E: ${activeDevicesCount} \u0438\u0437 ${trustedDevices.length}`);
    if (activeDevicesCount > 0) {
      console.log("\u0415\u0441\u0442\u044C \u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0435 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430. \u0412\u044B\u0445\u043E\u0434 \u0438\u0437 \u0440\u0435\u0436\u0438\u043C\u0430 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F.");
      this.waitingMode = false;
      if (this.options.fullSyncInterval && !this.fullSyncInterval) {
        this.fullSyncInterval = setInterval(
          this.performFullSync.bind(this),
          this.options.fullSyncInterval
        );
      }
      console.log("\u0417\u0430\u043F\u0443\u0441\u043A \u043D\u0430\u0447\u0430\u043B\u044C\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
      await this.performFullSync();
    } else {
      console.log("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u041E\u0441\u0442\u0430\u0451\u043C\u0441\u044F \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F.");
      this.waitingMode = true;
      setTimeout(() => this.checkActiveTrustedDevices(), 6e4);
    }
  }
  /**
   * Остановить процесс синхронизации
   */
  stop() {
    this.fileWatcher.stopWatching();
    this.relayClient.disconnect();
    if (this.fullSyncInterval) {
      clearInterval(this.fullSyncInterval);
      this.fullSyncInterval = null;
    }
    this.saveSyncState();
  }
  /**
   * Обработчик изменения файла
   */
  async handleFileChange(change) {
    try {
      if (this.isSyncing) {
        return;
      }
      this.pendingChangesCount++;
      switch (change.type) {
        case "create":
        case "modify":
          await this.handleFileCreateOrModify(change);
          break;
        case "delete":
          await this.handleFileDelete(change);
          break;
        case "rename":
          await this.handleFileRename(change);
          break;
      }
      this.saveSyncState();
      if (this.waitingMode && this.pendingChangesCount >= 5) {
        console.log(`\u041D\u0430\u043A\u043E\u043F\u043B\u0435\u043D\u043E ${this.pendingChangesCount} \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439. \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u043D\u0430\u043B\u0438\u0447\u0438\u0435 \u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432...`);
        this.checkActiveTrustedDevices();
      }
    } catch (error) {
      console.error("Error handling file change:", error);
      new import_obsidian4.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043B\u0430: " + error.message);
    }
  }
  /**
   * Обработчик создания или изменения файла
   */
  async handleFileCreateOrModify(change) {
    const file = change.file;
    const content = await this.app.vault.read(file);
    const hash = await CryptoHelper.hashString(content);
    const existingFile = this.syncState.files[file.path];
    if (existingFile && existingFile.hash === hash) {
      this.pendingChangesCount = Math.max(0, this.pendingChangesCount - 1);
      return;
    }
    this.syncState.files[file.path] = {
      path: file.path,
      hash,
      mtime: file.stat.mtime,
      size: file.stat.size
    };
    if (!this.waitingMode) {
      console.log(`\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${file.path}`);
      await this.syncFileWithPeers(file.path, content, hash, file.stat.mtime);
    } else {
      console.log(`\u0424\u0430\u0439\u043B ${file.path} \u0438\u0437\u043C\u0435\u043D\u0435\u043D, \u043D\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u0430 (\u0440\u0435\u0436\u0438\u043C \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F)`);
    }
  }
  /**
   * Обработчик удаления файла
   */
  async handleFileDelete(change) {
    const filePath = change.path;
    if (!this.syncState.files[filePath]) {
      this.pendingChangesCount = Math.max(0, this.pendingChangesCount - 1);
      return;
    }
    this.syncState.files[filePath] = {
      ...this.syncState.files[filePath],
      deleted: true
    };
    if (!this.waitingMode) {
      console.log(`\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${filePath}`);
      await this.syncFileDeletion(filePath);
    } else {
      console.log(`\u0424\u0430\u0439\u043B ${filePath} \u0443\u0434\u0430\u043B\u0435\u043D, \u043D\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u0430 (\u0440\u0435\u0436\u0438\u043C \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F)`);
    }
  }
  /**
   * Обработчик переименования файла
   */
  async handleFileRename(change) {
    const oldPath = change.oldPath;
    const newPath = change.path;
    const file = change.file;
    if (!oldPath) {
      console.error("Old path is missing in rename event");
      this.pendingChangesCount = Math.max(0, this.pendingChangesCount - 1);
      return;
    }
    const oldMetadata = this.syncState.files[oldPath];
    if (oldMetadata) {
      this.syncState.files[oldPath] = {
        ...oldMetadata,
        deleted: true
      };
      if (!this.waitingMode) {
        await this.syncFileDeletion(oldPath);
      } else {
        console.log(`\u0424\u0430\u0439\u043B ${oldPath} \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D, \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u0430 \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u043E (\u0440\u0435\u0436\u0438\u043C \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F)`);
      }
    }
    const content = await this.app.vault.read(file);
    const hash = await CryptoHelper.hashString(content);
    this.syncState.files[newPath] = {
      path: newPath,
      hash,
      mtime: file.stat.mtime,
      size: file.stat.size
    };
    if (!this.waitingMode) {
      console.log(`\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 ${newPath}`);
      await this.syncFileWithPeers(newPath, content, hash, file.stat.mtime);
    } else {
      console.log(`\u0424\u0430\u0439\u043B ${oldPath} \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D \u0432 ${newPath}, \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u0430 (\u0440\u0435\u0436\u0438\u043C \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F)`);
    }
  }
  /**
   * Синхронизация файла с доверенными устройствами
   * @param path Путь к файлу
   * @param content Содержимое файла
   * @param hash Хеш файла
   * @param mtime Время модификации
   * @param isNew Флаг, указывающий, что файл новый/недавно изменен
   * @param specificDevices Список ID устройств для синхронизации (если задан, то только им)
   * @param requestId ID запроса (если отправка в ответ на запрос)
   */
  async syncFileWithPeers(path, content, hash, mtime, isNew = true, specificDevices, requestId) {
    if (!this.relayClient.isConnected) {
      console.error(`\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B ${path}: \u043D\u0435\u0442 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043E\u043C`);
      new import_obsidian4.Notice(`\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B ${path}: \u043D\u0435\u0442 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043E\u043C. \u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u044B \u043F\u0440\u0438 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F.`);
      return;
    }
    const allTrustedDevices = this.relayClient.getTrustedDevices();
    const targetDevices = specificDevices ? allTrustedDevices.filter((device) => specificDevices.includes(device.id)) : allTrustedDevices;
    if (!Array.isArray(targetDevices) || targetDevices.length === 0) {
      console.log(`\u041F\u0440\u043E\u043F\u0443\u0441\u043A \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path}: \u043D\u0435\u0442 \u0446\u0435\u043B\u0435\u0432\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
      return;
    }
    try {
      const isMarkdown = path.endsWith(".md");
      const isLargeFile = content.length > 1e4;
      let compressedContent = content;
      let compressionInfo = { compressed: false, originalSize: content.length, compressedSize: content.length };
      if (isMarkdown && isLargeFile) {
        const targetDeviceIds = targetDevices.map((device) => typeof device === "string" ? device : device.id);
        const remoteFile = this.findRemoteFileVersion(path, targetDeviceIds);
        if (remoteFile && remoteFile.hash !== hash) {
          try {
            const targetDeviceId = typeof targetDevices[0] === "string" ? targetDevices[0] : targetDevices[0].id;
            const baseContent = await this.getRemoteFileContent(path, remoteFile.hash, targetDeviceId);
            if (baseContent) {
              const delta = this.createDelta(baseContent, content);
              if (delta.length < content.length * 0.7) {
                console.log(`\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C \u0434\u0435\u043B\u044C\u0442\u0430-\u0441\u0436\u0430\u0442\u0438\u0435 \u0434\u043B\u044F ${path}: ${delta.length} \u0431\u0430\u0439\u0442 (${Math.round(delta.length / content.length * 100)}% \u043E\u0442 \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u0430)`);
                compressedContent = delta;
                compressionInfo = {
                  compressed: true,
                  originalSize: content.length,
                  compressedSize: delta.length
                };
                compressedContent = delta;
                compressionInfo = {
                  compressed: true,
                  originalSize: content.length,
                  compressedSize: delta.length
                };
                const deltaEncryptedData = await CryptoHelper.encrypt(delta, this.encryptionPassword);
                let successCount = 0;
                for (const device of targetDevices) {
                  const deviceId = typeof device === "string" ? device : device.id;
                  const success = this.relayClient.sendMessage({
                    type: "fileSync",
                    targetDeviceId: deviceId,
                    payload: {
                      path,
                      encryptedData: deltaEncryptedData,
                      mtime,
                      hash,
                      priority: isNew ? "high" : "normal",
                      compression: compressionInfo,
                      isMarkdown: true,
                      deltaData: {
                        baseHash: remoteFile.hash,
                        isDelta: true
                      }
                    }
                  });
                  if (success) {
                    successCount++;
                  }
                }
                if (successCount === 0) {
                  console.error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0434\u0435\u043B\u044C\u0442\u0443 \u0434\u043B\u044F ${path} \u043D\u0438 \u043E\u0434\u043D\u043E\u043C\u0443 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 \u0438\u0437-\u0437\u0430 \u043F\u0440\u043E\u0431\u043B\u0435\u043C \u0441 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435\u043C`);
                }
                console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0430 \u0434\u0435\u043B\u044C\u0442\u0430 \u0434\u043B\u044F ${path} \u043D\u0430 ${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
                return;
              } else {
                console.log(`\u0414\u0435\u043B\u044C\u0442\u0430 \u0434\u043B\u044F ${path} \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u0430\u044F, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C \u043F\u043E\u043B\u043D\u043E\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435`);
              }
            }
          } catch (deltaError) {
            console.warn(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0437\u0434\u0430\u0442\u044C \u0434\u0435\u043B\u044C\u0442\u0443 \u0434\u043B\u044F ${path}:`, deltaError);
          }
        }
        compressedContent = content;
        compressionInfo = {
          compressed: true,
          originalSize: content.length,
          compressedSize: compressedContent.length
        };
      } else if (isLargeFile) {
        try {
          const isTextFile = path.match(/\.(txt|json|xml|css|js|html|htm|csv|log)$/i) !== null;
          if (isTextFile) {
            compressedContent = this.compressTextContent(content);
          } else {
            compressedContent = content;
          }
          compressionInfo = {
            compressed: compressedContent.length < content.length,
            originalSize: content.length,
            compressedSize: compressedContent.length
          };
          if (compressedContent.length >= content.length) {
            compressedContent = content;
            compressionInfo.compressed = false;
            compressionInfo.compressedSize = content.length;
          }
          console.log(`\u0421\u0436\u0430\u0442\u0438\u0435 \u0434\u043B\u044F ${path}: ${compressionInfo.originalSize} -> ${compressionInfo.compressedSize} \u0431\u0430\u0439\u0442 (${Math.round(compressionInfo.compressedSize / compressionInfo.originalSize * 100)}%)`);
        } catch (compressionError) {
          console.warn(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0436\u0430\u0442\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path}:`, compressionError);
          compressedContent = content;
          compressionInfo = {
            compressed: false,
            originalSize: content.length,
            compressedSize: content.length
          };
        }
      }
      console.log(`\u0428\u0438\u0444\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u0430 ${path} (${content.length} \u0431\u0430\u0439\u0442)...`);
      const encryptedData = await CryptoHelper.encrypt(compressedContent, this.encryptionPassword);
      const fileMessage = {
        path,
        encryptedData,
        mtime,
        hash,
        priority: isNew ? "high" : "normal",
        compression: compressionInfo,
        isMarkdown,
        responseToRequestId: requestId
      };
      console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0444\u0430\u0439\u043B\u0430 ${path} (${isNew ? "\u043D\u043E\u0432\u044B\u0439/\u0438\u0437\u043C\u0435\u043D\u0451\u043D\u043D\u044B\u0439" : "\u0441\u0442\u0430\u0440\u044B\u0439"}) \u043D\u0430 ${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432...`);
      if (!isLargeFile || specificDevices) {
        const sendPromises = targetDevices.map(async (device) => {
          try {
            const success = this.relayClient.sendMessage({
              type: "fileSync",
              targetDeviceId: device.id,
              requestId,
              // Передаем requestId, если это ответ на запрос
              payload: fileMessage
            });
            if (!success) {
              console.error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0444\u0430\u0439\u043B ${path} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 ${device.id} \u0438\u0437-\u0437\u0430 \u043F\u0440\u043E\u0431\u043B\u0435\u043C \u0441 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435\u043C`);
              return false;
            }
            return true;
          } catch (deviceError) {
            console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u043D\u0430 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E ${device.id}:`, deviceError);
            return false;
          }
        });
        const results = await Promise.allSettled(sendPromises);
        const successCount = results.filter((r) => r.status === "fulfilled" && r.value).length;
        console.log(`\u0424\u0430\u0439\u043B ${path} \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D \u043D\u0430 ${successCount}/${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
        return;
      }
      const metadataMessage = {
        path,
        hash,
        mtime,
        size: content.length,
        priority: isNew ? "high" : "normal",
        isMarkdown
      };
      let metadataSuccessCount = 0;
      for (const device of targetDevices) {
        const success = this.relayClient.sendMessage({
          type: "fileMetadataOnly",
          // Отличается от fileMetadata - содержит только метаданные одного файла
          targetDeviceId: device.id,
          payload: metadataMessage
        });
        if (success) {
          metadataSuccessCount++;
        }
      }
      if (metadataSuccessCount === 0 && targetDevices.length > 0) {
        console.error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u0430 ${path} \u043D\u0438 \u043E\u0434\u043D\u043E\u043C\u0443 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 \u0438\u0437-\u0437\u0430 \u043F\u0440\u043E\u0431\u043B\u0435\u043C \u0441 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435\u043C`);
      } else if (metadataSuccessCount < targetDevices.length) {
        console.warn(`\u041C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u0430 ${path} \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u044B \u0442\u043E\u043B\u044C\u043A\u043E ${metadataSuccessCount} \u0438\u0437 ${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 \u0438\u0437-\u0437\u0430 \u043F\u0440\u043E\u0431\u043B\u0435\u043C \u0441 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435\u043C`);
      }
      this.saveContentToCache(path, content, hash);
      console.log(`\u041C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u0430 ${path} \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u044B \u043D\u0430 ${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u041E\u0436\u0438\u0434\u0430\u0435\u043C \u0437\u0430\u043F\u0440\u043E\u0441\u044B \u043D\u0430 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E.`);
    } catch (error) {
      console.error(`Error syncing file ${path}:`, error);
      throw new Error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B ${path}: ${error.message}`);
    }
  }
  /**
   * Найти версию файла на одном из целевых устройств для дельта-синхронизации
   */
  findRemoteFileVersion(path, targetDeviceIds) {
    for (const deviceId of targetDeviceIds) {
      const deviceMeta = this.deviceFileMetadata.get(deviceId);
      if (deviceMeta && deviceMeta[path]) {
        return deviceMeta[path];
      }
    }
    return null;
  }
  /**
   * Запросить содержимое файла с другого устройства для дельта-синхронизации
   */
  async getRemoteFileContent(path, hash, deviceId) {
    const cachedContent = this.getContentFromCache(path, hash);
    if (cachedContent) {
      console.log(`\u041D\u0430\u0439\u0434\u0435\u043D\u0430 \u0432\u0435\u0440\u0441\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${path} \u0432 \u043A\u044D\u0448\u0435 (hash: ${hash.substring(0, 8)})`);
      return cachedContent;
    }
    try {
      console.log(`\u0417\u0430\u043F\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043C \u0432\u0435\u0440\u0441\u0438\u044E \u0444\u0430\u0439\u043B\u0430 ${path} \u0443 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${deviceId} \u0434\u043B\u044F \u0434\u0435\u043B\u044C\u0442\u0430-\u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...`);
      const requestId = Date.now().toString() + "-delta-" + Math.random().toString(36).substring(2, 7);
      const responsePromise = new Promise((resolve) => {
        const handleFileResponse = async (message) => {
          if (message.type === "fileSync" && message.sourceDeviceId === deviceId && message.responseToRequestId === requestId) {
            if (message.payload && message.payload.path === path && message.payload.encryptedData) {
              try {
                const decryptedContent = await CryptoHelper.decrypt(
                  message.payload.encryptedData,
                  this.encryptionPassword
                );
                console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u0430 \u0432\u0435\u0440\u0441\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${path} \u0434\u043B\u044F \u0434\u0435\u043B\u044C\u0442\u0430-\u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438`);
                resolve(decryptedContent);
                this.saveContentToCache(path, decryptedContent, message.payload.hash);
                return;
              } catch (error) {
                console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043E\u0432\u043A\u0435 \u0444\u0430\u0439\u043B\u0430 ${path}:`, error);
              }
            }
          }
          const originalCallback2 = this.relayClient["onMessageCallbackOriginal"];
          if (originalCallback2) {
            originalCallback2(message);
          }
        };
        const originalCallback = this.relayClient["onMessageCallback"];
        this.relayClient["onMessageCallbackOriginal"] = originalCallback;
        this.relayClient["onMessageCallback"] = handleFileResponse;
        this.relayClient.sendMessage({
          type: "requestFile",
          targetDeviceId: deviceId,
          requestId,
          payload: {
            path,
            hash,
            forDelta: true
            // Флаг, что это запрос для дельта-синхронизации
          }
        });
        setTimeout(() => {
          this.relayClient["onMessageCallback"] = originalCallback;
          console.log(`\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 ${path} \u0434\u043B\u044F \u0434\u0435\u043B\u044C\u0442\u0430-\u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438`);
          resolve(null);
        }, 1e4);
      });
      return await responsePromise;
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 ${path} \u0434\u043B\u044F \u0434\u0435\u043B\u044C\u0442\u0430-\u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438:`, error);
      return null;
    }
  }
  /**
   * Создать дельту между старым и новым содержимым
   */
  createDelta(baseContent, newContent) {
    try {
      const baseLines = baseContent.split(/\r?\n/);
      const newLines = newContent.split(/\r?\n/);
      let commonStart = 0;
      while (commonStart < baseLines.length && commonStart < newLines.length && baseLines[commonStart] === newLines[commonStart]) {
        commonStart++;
      }
      let commonEnd = 0;
      while (commonEnd < baseLines.length - commonStart && commonEnd < newLines.length - commonStart && baseLines[baseLines.length - 1 - commonEnd] === newLines[newLines.length - 1 - commonEnd]) {
        commonEnd++;
      }
      const baseMiddle = baseLines.slice(commonStart, baseLines.length - commonEnd);
      const newMiddle = newLines.slice(commonStart, newLines.length - commonEnd);
      const delta = JSON.stringify({
        commonStart,
        commonEnd,
        baseMiddleLength: baseMiddle.length,
        newMiddle: newMiddle.join("\n")
      });
      return delta;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u0434\u0435\u043B\u044C\u0442\u044B:", error);
      return newContent;
    }
  }
  /**
   * Получить файл по его хешу (для применения дельты)
   */
  async getFileWithHash(path, hash) {
    const cachedContent = this.getContentFromCache(path, hash);
    if (cachedContent) {
      return cachedContent;
    }
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian4.TFile) {
      try {
        const content = await this.app.vault.read(file);
        const currentHash = await CryptoHelper.hashString(content);
        if (currentHash === hash) {
          this.saveContentToCache(path, content, hash);
          return content;
        }
      } catch (error) {
        console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0447\u0442\u0435\u043D\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path}:`, error);
      }
    }
    const trustedDevices = this.relayClient.getTrustedDevices();
    if (trustedDevices.length > 0) {
      for (const device of trustedDevices) {
        const remoteContent = await this.getRemoteFileContent(path, hash, device.id);
        if (remoteContent) {
          return remoteContent;
        }
      }
    }
    return null;
  }
  /**
   * Применить дельту к базовому содержимому
   */
  applyDelta(baseContent, delta) {
    try {
      const deltaObj = JSON.parse(delta);
      const baseLines = baseContent.split(/\r?\n/);
      const commonStart = deltaObj.commonStart;
      const commonEnd = deltaObj.commonEnd;
      const startPart = baseLines.slice(0, commonStart);
      const endPart = baseLines.slice(baseLines.length - commonEnd);
      const newMiddle = deltaObj.newMiddle.split(/\r?\n/);
      const newContent = [...startPart, ...newMiddle, ...endPart].join("\n");
      return newContent;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u0438 \u0434\u0435\u043B\u044C\u0442\u044B:", error);
      throw new Error("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0434\u0435\u043B\u044C\u0442\u0443 \u043A \u0444\u0430\u0439\u043B\u0443");
    }
  }
  /**
   * Сжатие текстового содержимого (упрощенный алгоритм)
   */
  compressTextContent(content) {
    try {
      const lines = content.split(/\r?\n/);
      const dictionary = {};
      const MIN_STRING_LENGTH = 20;
      for (const line of lines) {
        if (line.length >= MIN_STRING_LENGTH) {
          dictionary[line] = (dictionary[line] || 0) + 1;
        }
      }
      const frequentStrings = Object.entries(dictionary).filter(([_, count]) => count >= 2).map(([str]) => str).slice(0, 50);
      if (frequentStrings.length === 0) {
        return content;
      }
      let compressedLines = [...lines];
      for (let i = 0; i < frequentStrings.length; i++) {
        const str = frequentStrings[i];
        const placeholder = `###REF${i}###`;
        for (let j = 0; j < compressedLines.length; j++) {
          if (compressedLines[j] === str) {
            compressedLines[j] = placeholder;
          }
        }
      }
      const compressed = {
        dictionary: frequentStrings,
        content: compressedLines.join("\n")
      };
      return JSON.stringify(compressed);
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0436\u0430\u0442\u0438\u0438 \u0442\u0435\u043A\u0441\u0442\u043E\u0432\u043E\u0433\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E:", error);
      return content;
    }
  }
  /**
   * Распаковка сжатого текстового содержимого
   */
  decompressTextContent(compressedContent) {
    try {
      const compressed = JSON.parse(compressedContent);
      if (!compressed.dictionary || !compressed.content) {
        return compressedContent;
      }
      let decompressedContent = compressed.content;
      for (let i = 0; i < compressed.dictionary.length; i++) {
        const placeholder = `###REF${i}###`;
        const regex = new RegExp(placeholder, "g");
        decompressedContent = decompressedContent.replace(regex, compressed.dictionary[i]);
      }
      return decompressedContent;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0440\u0430\u0441\u043F\u0430\u043A\u043E\u0432\u043A\u0435 \u0441\u0436\u0430\u0442\u043E\u0433\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E:", error);
      return compressedContent;
    }
  }
  saveContentToCache(path, content, hash) {
    if (this.fileContentCache.size > 100) {
      const oldestEntries = Array.from(this.fileContentCache.entries()).sort((a, b) => a[1].timestamp - b[1].timestamp).slice(0, 20);
      for (const [oldPath] of oldestEntries) {
        this.fileContentCache.delete(oldPath);
      }
    }
    this.fileContentCache.set(path, {
      content,
      hash,
      timestamp: Date.now()
    });
  }
  /**
   * Получить содержимое файла из кэша
   */
  getContentFromCache(path, hash) {
    const cached = this.fileContentCache.get(path);
    if (cached && cached.hash === hash) {
      return cached.content;
    }
    return null;
  }
  /**
   * Синхронизация удаления файла с доверенными устройствами
   */
  async syncFileDeletion(path) {
    const trustedDevices = this.relayClient.getTrustedDevices();
    if (!Array.isArray(trustedDevices) || trustedDevices.length === 0) {
      console.log(`\u041F\u0440\u043E\u043F\u0443\u0441\u043A \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${path}: \u043D\u0435\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
      return;
    }
    try {
      const deleteMessage = {
        path,
        deleted: true,
        mtime: Date.now(),
        hash: ""
        // Хеш не нужен при удалении
      };
      console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u043E\u0431 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path} \u043D\u0430 ${trustedDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432...`);
      let successCount = 0;
      for (const device of trustedDevices) {
        try {
          console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u043E\u0431 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438 ${path} \u043D\u0430 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E ${device.id}...`);
          this.relayClient.sendMessage({
            type: "fileSync",
            targetDeviceId: device.id,
            payload: deleteMessage
          });
          successCount++;
        } catch (deviceError) {
          console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0443\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u044F \u043E\u0431 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438 \u043D\u0430 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E ${device.id}:`, deviceError);
        }
      }
      console.log(`\u0423\u0432\u0435\u0434\u043E\u043C\u043B\u0435\u043D\u0438\u0435 \u043E\u0431 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path} \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E \u043D\u0430 ${successCount}/${trustedDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
    } catch (error) {
      console.error(`Error syncing file deletion ${path}:`, error);
      throw new Error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u0430 ${path}: ${error.message}`);
    }
  }
  /**
   * Обработчик сообщения от сервера
   */
  async handleSyncMessage(message) {
    try {
      if (message.type === "message" && message.payload && message.payload.action === "devicePing" && message.payload.pingId) {
        console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043F\u0438\u043D\u0433 \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${message.deviceName || message.sourceDeviceId}`);
        this.relayClient.sendMessage({
          type: "message",
          targetDeviceId: message.sourceDeviceId,
          payload: {
            action: "devicePingResponse",
            pingId: message.payload.pingId
          }
        });
        if (this.waitingMode && this.relayClient.isDeviceTrusted(message.sourceDeviceId || "")) {
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043F\u0438\u043D\u0433 \u043E\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u043E\u0433\u043E \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430. \u0412\u044B\u0445\u043E\u0434\u0438\u043C \u0438\u0437 \u0440\u0435\u0436\u0438\u043C\u0430 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F.");
          this.waitingMode = false;
          if (this.pendingChangesCount > 0) {
            console.log(`\u0415\u0441\u0442\u044C ${this.pendingChangesCount} \u043D\u0430\u043A\u043E\u043F\u043B\u0435\u043D\u043D\u044B\u0445 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439. \u0417\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u043C \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E.`);
            setTimeout(() => this.performFullSync(), 1e3);
          }
        }
        return;
      }
      if (message.type === "message" && message.payload && message.payload.action === "devicePingResponse") {
        return;
      }
      if (message.type === "requestFileMetadata") {
        console.log("\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445...");
        this.handleFileMetadataRequest(message);
        return;
      }
      if (message.type === "fileMetadata") {
        return;
      }
      if (message.type === "fileMetadataOnly" && message.payload && typeof message.payload === "object") {
        await this.handleFileMetadataOnly(message);
        return;
      }
      if (message.type === "requestFile" && message.payload && typeof message.payload === "object") {
        const path = message.payload.path;
        if (path && message.sourceDeviceId) {
          console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u0437\u0430\u043F\u0440\u043E\u0441 \u043D\u0430 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0443 \u0444\u0430\u0439\u043B\u0430 ${path} \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${message.deviceName || message.sourceDeviceId}`);
          await this.handleFileRequest(path, message.sourceDeviceId, message.requestId);
        }
        return;
      }
      if (message.type === "fileSync" && message.payload) {
        console.log("\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F fileSync...");
        if (this.waitingMode) {
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u0434\u0430\u043D\u043D\u044B\u0435 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438, \u0432\u044B\u0445\u043E\u0434\u0438\u043C \u0438\u0437 \u0440\u0435\u0436\u0438\u043C\u0430 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F");
          this.waitingMode = false;
        }
        await this.processFileSyncMessage(message.payload);
      } else if (message.type === "message" && message.payload && typeof message.payload === "object" && (message.payload.path || message.payload.encryptedData || message.payload.deleted)) {
        console.log("\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F message \u0441 \u0434\u0430\u043D\u043D\u044B\u043C\u0438 \u0444\u0430\u0439\u043B\u043E\u0432\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
        if (this.waitingMode) {
          console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u0434\u0430\u043D\u043D\u044B\u0435 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438, \u0432\u044B\u0445\u043E\u0434\u0438\u043C \u0438\u0437 \u0440\u0435\u0436\u0438\u043C\u0430 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F");
          this.waitingMode = false;
        }
        await this.processFileSyncMessage(message.payload);
      }
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438:", error);
      new import_obsidian4.Notice(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: ${error.message}`);
    }
  }
  /**
   * Обработка метаданных отдельного файла (сигнальная система)
   */
  async handleFileMetadataOnly(message) {
    try {
      if (!message.payload || !message.sourceDeviceId)
        return;
      const payload = message.payload;
      const path = payload.path;
      if (!path) {
        console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u0430 \u0431\u0435\u0437 \u0443\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u043F\u0443\u0442\u0438");
        return;
      }
      console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u0430 ${path} \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${message.deviceName || message.sourceDeviceId}`);
      const needFile = await this.checkIfFileNeeded(path, payload.hash, payload.mtime);
      if (needFile) {
        console.log(`\u0417\u0430\u043F\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043C \u0444\u0430\u0439\u043B ${path} \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${message.sourceDeviceId}`);
        this.relayClient.sendMessage({
          type: "requestFile",
          targetDeviceId: message.sourceDeviceId,
          requestId: Date.now().toString() + "-" + Math.random().toString(36).substr(2, 5),
          payload: {
            path,
            hash: payload.hash
          }
        });
      } else {
        console.log(`\u0424\u0430\u0439\u043B ${path} \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C, \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u0435\u043C`);
      }
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u0444\u0430\u0439\u043B\u0430:`, error);
    }
  }
  /**
   * Проверить, нужен ли нам файл с указанными метаданными
   */
  async checkIfFileNeeded(path, hash, remoteMtime) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian4.TFile)) {
      return true;
    }
    const localMetadata = this.syncState.files[path];
    if (!localMetadata) {
      const content = await this.app.vault.read(file);
      const localHash = await CryptoHelper.hashString(content);
      return localHash !== hash;
    }
    if (localMetadata.hash !== hash) {
      if (localMetadata.mtime > remoteMtime) {
        console.log(`\u041A\u041E\u041D\u0424\u041B\u0418\u041A\u0422 \u0412\u0415\u0420\u0421\u0418\u0419: \u041B\u043E\u043A\u0430\u043B\u044C\u043D\u0430\u044F \u0432\u0435\u0440\u0441\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${path} \u043D\u043E\u0432\u0435\u0435 (${new Date(localMetadata.mtime).toISOString()}) \u0447\u0435\u043C \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u0430\u044F (${new Date(remoteMtime).toISOString()}). \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u043C \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0443\u044E \u0432\u0435\u0440\u0441\u0438\u044E.`);
        return false;
      }
      console.log(`\u0423\u0434\u0430\u043B\u0435\u043D\u043D\u0430\u044F \u0432\u0435\u0440\u0441\u0438\u044F \u0444\u0430\u0439\u043B\u0430 ${path} \u043D\u043E\u0432\u0435\u0435 (${new Date(remoteMtime).toISOString()}) \u0447\u0435\u043C \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0430\u044F (${new Date(localMetadata.mtime).toISOString()}). \u0417\u0430\u043F\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043C \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435.`);
      return true;
    }
    return false;
  }
  /**
   * Обработчик запроса на получение файла
   */
  async handleFileRequest(path, sourceDeviceId, requestId) {
    try {
      console.log(`\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u043D\u0430 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u0430 ${path}...`);
      const file = this.app.vault.getAbstractFileByPath(path);
      if (!(file instanceof import_obsidian4.TFile)) {
        console.log(`\u0424\u0430\u0439\u043B ${path} \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0438\u043B\u0438 \u043D\u0435 \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u0444\u0430\u0439\u043B\u043E\u043C`);
        return;
      }
      const content = await this.app.vault.read(file);
      const hash = await CryptoHelper.hashString(content);
      await this.syncFileWithPeers(path, content, hash, file.stat.mtime, true, [sourceDeviceId], requestId);
      console.log(`\u0424\u0430\u0439\u043B ${path} \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 ${sourceDeviceId} \u043F\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0443`);
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u043D\u0430 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u0430 ${path}:`, error);
    }
  }
  /**
   * Обработка сообщения синхронизации файла
   */
  async processFileSyncMessage(fileMessage) {
    const { path, encryptedData, deleted, mtime, hash, priority, compression } = fileMessage;
    try {
      if (deleted) {
        const existingFile2 = this.app.vault.getAbstractFileByPath(path);
        if (existingFile2) {
          await this.app.vault.delete(existingFile2);
          if (this.syncState.files[path]) {
            this.syncState.files[path] = {
              ...this.syncState.files[path],
              deleted: true
            };
          }
          console.log(`\u0424\u0430\u0439\u043B \u0443\u0434\u0430\u043B\u0435\u043D: ${path}`);
        }
        return;
      }
      if (!encryptedData) {
        console.error(`\u041E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044E\u0442 \u0437\u0430\u0448\u0438\u0444\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u0430 ${path}`);
        return;
      }
      const existingFile = this.syncState.files[path];
      if (existingFile && existingFile.hash === hash) {
        console.log(`\u041F\u0440\u043E\u043F\u0443\u0441\u043A \u0444\u0430\u0439\u043B\u0430 ${path}: \u0443 \u043D\u0430\u0441 \u0443\u0436\u0435 \u0435\u0441\u0442\u044C \u0430\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u0430\u044F \u0432\u0435\u0440\u0441\u0438\u044F`);
        return;
      }
      const priorityInfo = priority || "normal";
      console.log(`\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0444\u0430\u0439\u043B\u0430 ${path} \u0441 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442\u043E\u043C ${priorityInfo}`);
      if (compression && compression.compressed) {
        console.log(`\u0424\u0430\u0439\u043B \u0441\u0436\u0430\u0442: ${compression.compressedSize} \u0431\u0430\u0439\u0442 (\u0438\u0441\u0445\u043E\u0434\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440: ${compression.originalSize} \u0431\u0430\u0439\u0442)`);
      }
      let decryptedContent = await CryptoHelper.decrypt(encryptedData, this.encryptionPassword);
      if (fileMessage.deltaData && fileMessage.deltaData.baseHash && fileMessage.deltaData.isDelta) {
        console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u0430 \u0434\u0435\u043B\u044C\u0442\u0430 \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u0430 ${path}. \u041F\u0440\u0438\u043C\u0435\u043D\u044F\u0435\u043C \u043A \u0431\u0430\u0437\u043E\u0432\u043E\u0439 \u0432\u0435\u0440\u0441\u0438\u0438...`);
        try {
          const baseContent = await this.getFileWithHash(path, fileMessage.deltaData.baseHash) || null;
          if (baseContent) {
            decryptedContent = this.applyDelta(baseContent, decryptedContent);
            console.log(`\u0414\u0435\u043B\u044C\u0442\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0430 \u043A \u0444\u0430\u0439\u043B\u0443 ${path}`);
          } else {
            console.error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043D\u0430\u0439\u0442\u0438 \u0431\u0430\u0437\u043E\u0432\u0443\u044E \u0432\u0435\u0440\u0441\u0438\u044E \u0444\u0430\u0439\u043B\u0430 ${path} \u0441 \u0445\u0435\u0448\u0435\u043C ${fileMessage.deltaData.baseHash}`);
            throw new Error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0434\u0435\u043B\u044C\u0442\u0443: \u0431\u0430\u0437\u043E\u0432\u0430\u044F \u0432\u0435\u0440\u0441\u0438\u044F \u0444\u0430\u0439\u043B\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430`);
          }
        } catch (deltaError) {
          console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u0438 \u0434\u0435\u043B\u044C\u0442\u044B \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u0430 ${path}:`, deltaError);
          throw new Error(`\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0434\u0435\u043B\u044C\u0442\u0443: ${deltaError.message}`);
        }
      }
      let finalContent = decryptedContent;
      if (compression && compression.compressed && !fileMessage.deltaData) {
        try {
          if (decryptedContent.startsWith("{") && decryptedContent.includes('"dictionary":')) {
            finalContent = this.decompressTextContent(decryptedContent);
            console.log(`\u0420\u0430\u0441\u043F\u0430\u043A\u043E\u0432\u0430\u043D\u043E \u0441\u0436\u0430\u0442\u043E\u0435 \u0442\u0435\u043A\u0441\u0442\u043E\u0432\u043E\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u0434\u043B\u044F ${path}`);
          } else {
            finalContent = decryptedContent;
          }
        } catch (decompressError) {
          console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0440\u0430\u0441\u043F\u0430\u043A\u043E\u0432\u043A\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 ${path}:`, decompressError);
          finalContent = decryptedContent;
        }
      }
      const dirPath = path.split("/").slice(0, -1).join("/");
      if (dirPath && !this.app.vault.getAbstractFileByPath(dirPath)) {
        await this.app.vault.createFolder(dirPath);
      }
      const existingFileObj = this.app.vault.getAbstractFileByPath(path);
      if (existingFileObj instanceof import_obsidian4.TFile) {
        await this.app.vault.modify(existingFileObj, finalContent);
      } else {
        await this.app.vault.create(path, finalContent);
      }
      this.syncState.files[path] = {
        path,
        hash,
        mtime,
        size: finalContent.length
      };
      console.log(`\u0424\u0430\u0439\u043B \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D: ${path} (${finalContent.length} \u0431\u0430\u0439\u0442)`);
    } catch (error) {
      console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u0430 ${path}:`, error);
      new import_obsidian4.Notice(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path}: ${error.message}`);
    }
  }
  /**
   * Обработчик изменения соединения
   */
  handleConnectionChange(connected) {
    if (connected) {
      new import_obsidian4.Notice("\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
      this.performFullSync();
    } else {
      new import_obsidian4.Notice("\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u043E\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
    }
  }
  /**
   * Обработчик изменения списка доверенных устройств
   */
  handleTrustedDevicesChange(devices) {
    if (!devices) {
      console.log("\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u043F\u0443\u0441\u0442\u043E\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432");
      this.trustedDevices = [];
      return;
    }
    this.trustedDevices = devices;
    console.log("\u0421\u043F\u0438\u0441\u043E\u043A \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D:", devices);
    const hasDevices = Array.isArray(devices) && devices.length > 0;
    if (hasDevices) {
      console.log(`\u041E\u0431\u043D\u0430\u0440\u0443\u0436\u0435\u043D\u043E ${devices.length} \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432`);
      if (this.waitingMode) {
        console.log("\u041E\u0431\u043D\u0430\u0440\u0443\u0436\u0435\u043D\u044B \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0435 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F. \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0438\u0445 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u044C...");
        setTimeout(() => {
          this.checkActiveTrustedDevices();
        }, 1e3);
        return;
      }
      const lastSyncTime = this.syncState.lastSyncTime || 0;
      const timeSinceLastSync = Date.now() - lastSyncTime;
      if (timeSinceLastSync > 5 * 60 * 1e3 || this.pendingChangesCount > 0) {
        console.log(`${timeSinceLastSync > 5 * 60 * 1e3 ? "\u0414\u0430\u0432\u043D\u043E \u043D\u0435 \u0431\u044B\u043B\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438" : `\u041D\u0430\u043A\u043E\u043F\u043B\u0435\u043D\u043E ${this.pendingChangesCount} \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439`}, \u0437\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u043C \u043F\u043E\u043B\u043D\u0443\u044E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E`);
        setTimeout(() => {
          this.performFullSync();
        }, 2e3);
      }
    } else {
      console.log("\u041D\u0435\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u041F\u0435\u0440\u0435\u0445\u043E\u0434 \u0432 \u0440\u0435\u0436\u0438\u043C \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F.");
      this.waitingMode = true;
    }
  }
  /**
   * Обработчик запроса на синхронизацию
   */
  handleSyncRequest(request) {
    if (request.requestId) {
      this.pendingSyncRequests.set(request.requestId, request);
      new import_obsidian4.Notice(
        `\u0423\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u043E ${request.deviceName || "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E\u0435"} \u0437\u0430\u043F\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E. \u041F\u0435\u0440\u0435\u0439\u0434\u0438\u0442\u0435 \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043B\u0430\u0433\u0438\u043D\u0430 \u0434\u043B\u044F \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u044F.`
      );
    }
  }
  /**
   * Ответить на запрос синхронизации
   */
  async respondToSyncRequest(requestId, accept, trustPermanently) {
    console.log(`\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0442\u0432\u0435\u0442\u0430 \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: ${requestId}, accept=${accept}, trust=${trustPermanently}`);
    const request = this.pendingSyncRequests.get(requestId);
    if (!request || !request.sourceDeviceId) {
      console.error(`\u0417\u0430\u043F\u0440\u043E\u0441 ${requestId} \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0438\u043B\u0438 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 sourceDeviceId`);
      return false;
    }
    try {
      console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u043E\u0442\u0432\u0435\u0442\u0430 \u043D\u0430 \u0437\u0430\u043F\u0440\u043E\u0441 \u0447\u0435\u0440\u0435\u0437 RelayClient \u0434\u043B\u044F \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${request.sourceDeviceId}`);
      const success = await this.relayClient.respondToSyncRequest(
        requestId,
        request.sourceDeviceId,
        accept,
        trustPermanently
      );
      console.log(`\u041E\u0442\u0432\u0435\u0442 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D, \u0440\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442: ${success}`);
      this.pendingSyncRequests.delete(requestId);
      console.log(`\u0417\u0430\u043F\u0440\u043E\u0441 ${requestId} \u0443\u0434\u0430\u043B\u0435\u043D \u0438\u0437 \u0441\u043F\u0438\u0441\u043A\u0430 \u043E\u0436\u0438\u0434\u0430\u044E\u0449\u0438\u0445`);
      if (accept && trustPermanently) {
        console.log("\u0417\u0430\u043F\u0440\u043E\u0441 \u043F\u0440\u0438\u043D\u044F\u0442 \u0441 \u043F\u043E\u0441\u0442\u043E\u044F\u043D\u043D\u044B\u043C \u0434\u043E\u0432\u0435\u0440\u0438\u0435\u043C, \u0437\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u043C \u043F\u043E\u043B\u043D\u0443\u044E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E");
        setTimeout(() => {
          console.log("\u0417\u0430\u043F\u0443\u0441\u043A \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u043D\u043E\u0439 \u043F\u043E\u043B\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
          this.performFullSync();
        }, 2e3);
      }
      return success;
    } catch (error) {
      console.error("Error responding to sync request:", error);
      this.pendingSyncRequests.delete(requestId);
      return false;
    }
  }
  /**
   * Получить список ожидающих запросов на синхронизацию
   */
  getPendingSyncRequests() {
    return Array.from(this.pendingSyncRequests.values());
  }
  /**
   * Выполнить полную синхронизацию с доверенными устройствами
   */
  async performFullSync() {
    try {
      if (!this.relayClient.isConnected) {
        console.log("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u0430: \u043D\u0435\u0442 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
        return;
      }
      const trustedDevices = this.relayClient.getTrustedDevices();
      const hasTrustedDevices = Array.isArray(trustedDevices) && trustedDevices.length > 0;
      if (this.isSyncing) {
        console.log("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u0430: \u0443\u0436\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F");
        return;
      }
      if (this.waitingMode || !hasTrustedDevices) {
        console.log(`${this.waitingMode ? "\u041F\u043B\u0430\u0433\u0438\u043D \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F" : "\u041D\u0435\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432"}. \u041F\u0440\u043E\u0432\u0435\u0440\u043A\u0430 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0441\u0442\u0438...`);
        await this.checkActiveTrustedDevices();
        if (this.waitingMode) {
          console.log("\u041F\u043E\u0441\u043B\u0435 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438 \u043F\u043E-\u043F\u0440\u0435\u0436\u043D\u0435\u043C\u0443 \u043D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u0430.");
          await this.updateLocalFileState();
          return;
        }
        const updatedTrustedDevices = this.relayClient.getTrustedDevices();
        if (!Array.isArray(updatedTrustedDevices) || updatedTrustedDevices.length === 0) {
          console.log("\u041F\u043E\u0441\u043B\u0435 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438 \u0432\u0441\u0435 \u0435\u0449\u0435 \u043D\u0435\u0442 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432. \u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043E\u0442\u043B\u043E\u0436\u0435\u043D\u0430.");
          return;
        }
      }
      console.log(`\u041D\u0430\u0447\u0438\u043D\u0430\u0435\u043C \u0438\u043D\u0442\u0435\u043B\u043B\u0435\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u0443\u044E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E \u0441 ${trustedDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u043C\u0438...`);
      this.isSyncing = true;
      new import_obsidian4.Notice(`\u041D\u0430\u0447\u0430\u0442\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0441 ${trustedDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u043C\u0438`);
      console.log("\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432...");
      await this.updateLocalFileState();
      await this.requestFileMetadata(trustedDevices);
      const fileEntries = Object.entries(this.syncState.files);
      console.log(`\u0410\u043D\u0430\u043B\u0438\u0437 ${fileEntries.length} \u0444\u0430\u0439\u043B\u043E\u0432 \u0434\u043B\u044F \u0438\u043D\u0442\u0435\u043B\u043B\u0435\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...`);
      const filesForSync = [];
      let unchangedFiles = 0;
      let identicalFiles = 0;
      console.log("\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u041F\u0440\u043E\u0432\u0435\u0440\u043A\u0430 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 \u0434\u043B\u044F \u0438\u043D\u0442\u0435\u043B\u043B\u0435\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
      for (const [path, metadata] of fileEntries) {
        if (metadata.deleted) {
          continue;
        }
        const { needsSync, isNew, targetDevices } = this.fileNeedsSync(path, metadata, trustedDevices);
        if (needsSync && targetDevices.length > 0) {
          console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0424\u0430\u0439\u043B '${path}' \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0441 ${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u043C\u0438`);
          filesForSync.push({
            path,
            metadata,
            isNew,
            targetDevices
          });
        } else if (isNew && targetDevices.length === 0) {
          console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0424\u0430\u0439\u043B '${path}' \u043D\u0435\u0434\u0430\u0432\u043D\u043E \u0438\u0437\u043C\u0435\u043D\u0435\u043D, \u043D\u043E \u0438\u0434\u0435\u043D\u0442\u0438\u0447\u0435\u043D \u043D\u0430 \u0432\u0441\u0435\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u0445`);
          identicalFiles++;
        } else {
          console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0424\u0430\u0439\u043B '${path}' \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438`);
          unchangedFiles++;
        }
      }
      if (filesForSync.length === 0) {
        console.log("\u041D\u0435\u0442 \u0444\u0430\u0439\u043B\u043E\u0432, \u0442\u0440\u0435\u0431\u0443\u044E\u0449\u0438\u0445 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438. \u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u0430.");
        this.pendingChangesCount = 0;
        this.syncState.lastSyncTime = Date.now();
        this.saveSyncState();
        new import_obsidian4.Notice("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F: \u0432\u0441\u0435 \u0444\u0430\u0439\u043B\u044B \u0430\u043A\u0442\u0443\u0430\u043B\u044C\u043D\u044B");
        this.isSyncing = false;
        return;
      }
      filesForSync.sort((a, b) => {
        if (a.isNew !== b.isNew) {
          return a.isNew ? -1 : 1;
        }
        return a.metadata.size - b.metadata.size;
      });
      console.log(`\u041D\u0430\u0439\u0434\u0435\u043D\u043E ${filesForSync.length} \u0444\u0430\u0439\u043B\u043E\u0432 \u0434\u043B\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438, ${unchangedFiles} \u0444\u0430\u0439\u043B\u043E\u0432 \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u044E\u0442 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F`);
      if (filesForSync.length <= 10) {
        console.log("\u041D\u0435\u0431\u043E\u043B\u044C\u0448\u043E\u0439 \u043D\u0430\u0431\u043E\u0440 \u0444\u0430\u0439\u043B\u043E\u0432, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C \u043F\u0440\u044F\u043C\u0443\u044E \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0443...");
        await this.syncSmallFileSet(filesForSync);
      } else {
        await this.syncLargeFileSet(filesForSync);
      }
      this.syncState.lastSyncTime = Date.now();
      this.saveSyncState();
      this.pendingChangesCount = 0;
      const summary = `\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0430: \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E ${filesForSync.length} \u0444\u0430\u0439\u043B\u043E\u0432, \u0438\u0434\u0435\u043D\u0442\u0438\u0447\u043D\u044B\u0445 \u043D\u0430 \u0432\u0441\u0435\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u0445 ${identicalFiles}, \u043D\u0435 \u0442\u0440\u0435\u0431\u043E\u0432\u0430\u043B\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F ${unchangedFiles}`;
      console.log("\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: " + summary);
      new import_obsidian4.Notice(summary);
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438:", error);
      new import_obsidian4.Notice(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: ${error.message}`);
    } finally {
      this.isSyncing = false;
    }
  }
  /**
   * Синхронизация небольшого набора файлов (прямая отправка)
   */
  async syncSmallFileSet(files) {
    let syncedCount = 0;
    for (const { path, metadata, isNew, targetDevices } of files) {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian4.TFile) {
        try {
          const content = await this.app.vault.read(file);
          await this.syncFileWithPeers(path, content, metadata.hash, metadata.mtime, isNew, targetDevices);
          syncedCount++;
        } catch (fileError) {
          console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path}:`, fileError);
        }
      }
    }
    console.log(`\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E ${syncedCount} \u0444\u0430\u0439\u043B\u043E\u0432 \u043D\u0430\u043F\u0440\u044F\u043C\u0443\u044E`);
  }
  /**
   * Синхронизация большого набора файлов (пакетная обработка)
   */
  async syncLargeFileSet(files) {
    const highPriorityFiles = files.filter((f) => f.isNew);
    const normalPriorityFiles = files.filter((f) => !f.isNew);
    console.log(`\u0412\u044B\u0441\u043E\u043A\u0438\u0439 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442: ${highPriorityFiles.length} \u0444\u0430\u0439\u043B\u043E\u0432, \u043E\u0431\u044B\u0447\u043D\u044B\u0439 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442: ${normalPriorityFiles.length} \u0444\u0430\u0439\u043B\u043E\u0432`);
    if (highPriorityFiles.length > 0) {
      console.log("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432 \u0441 \u0432\u044B\u0441\u043E\u043A\u0438\u043C \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442\u043E\u043C...");
      const batchSize = 10;
      const batches = Math.ceil(highPriorityFiles.length / batchSize);
      for (let i = 0; i < batches; i++) {
        const batch = highPriorityFiles.slice(i * batchSize, (i + 1) * batchSize);
        await this.processBatch(batch, i + 1, batches, "\u0432\u044B\u0441\u043E\u043A\u043E\u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442\u043D\u044B\u0445");
      }
    }
    if (normalPriorityFiles.length > 0) {
      console.log("\u0421\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432 \u0441 \u043E\u0431\u044B\u0447\u043D\u044B\u043C \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442\u043E\u043C...");
      const batchSize = 20;
      const batches = Math.ceil(normalPriorityFiles.length / batchSize);
      for (let i = 0; i < batches; i++) {
        const batch = normalPriorityFiles.slice(i * batchSize, (i + 1) * batchSize);
        await this.processBatch(batch, i + 1, batches, "\u043E\u0431\u044B\u0447\u043D\u044B\u0445");
      }
    }
  }
  /**
   * Обработка пакета файлов
   */
  async processBatch(batch, batchNumber, totalBatches, batchType) {
    console.log(`\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043F\u0430\u043A\u0435\u0442\u0430 ${batchNumber}/${totalBatches} ${batchType} \u0444\u0430\u0439\u043B\u043E\u0432...`);
    const batchPromises = batch.map(async ({ path, metadata, isNew, targetDevices }) => {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian4.TFile) {
        try {
          const content = await this.app.vault.read(file);
          await this.syncFileWithPeers(path, content, metadata.hash, metadata.mtime, isNew, targetDevices);
          return true;
        } catch (fileError) {
          console.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path}:`, fileError);
          return false;
        }
      }
      return false;
    });
    const batchResults = await Promise.allSettled(batchPromises);
    const successfulSyncs = batchResults.filter(
      (result) => result.status === "fulfilled" && result.value === true
    ).length;
    console.log(`\u041F\u0430\u043A\u0435\u0442 ${batchNumber}/${totalBatches}: \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E ${successfulSyncs}/${batch.length} \u0444\u0430\u0439\u043B\u043E\u0432`);
    if (batchNumber < totalBatches) {
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
  }
  async requestFileMetadata(trustedDevices) {
    try {
      console.log("\u0417\u0430\u043F\u0440\u043E\u0441 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 \u0443 \u0434\u043E\u0432\u0435\u0440\u0435\u043D\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432...");
      this.deviceFileMetadata.clear();
      const metadataPromises = [];
      for (const device of trustedDevices) {
        const promise = new Promise((resolve) => {
          const requestId = Date.now().toString() + "-" + Math.random().toString(36).substr(2, 5);
          const handleMetadataResponse = (message) => {
            if (message.type === "fileMetadata" && message.requestId === requestId && message.sourceDeviceId === device.id) {
              if (message.payload && typeof message.payload === "object") {
                this.deviceFileMetadata.set(device.id, message.payload);
                console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${device.name || device.id}: ${Object.keys(message.payload).length} \u0444\u0430\u0439\u043B\u043E\u0432`);
              }
              const originalCallback2 = this.relayClient["onMessageCallbackOriginal"];
              if (originalCallback2) {
                this.relayClient["onMessageCallback"] = originalCallback2;
              }
              resolve();
            }
          };
          const originalCallback = this.relayClient["onMessageCallback"];
          this.relayClient["onMessageCallbackOriginal"] = originalCallback;
          this.relayClient["onMessageCallback"] = (message) => {
            handleMetadataResponse(message);
            originalCallback(message);
          };
          this.relayClient.sendMessage({
            type: "requestFileMetadata",
            targetDeviceId: device.id,
            requestId,
            payload: {
              deviceId: this.syncState.deviceId
            }
          });
          setTimeout(() => resolve(), 5e3);
        });
        metadataPromises.push(promise);
      }
      console.log("\u041E\u0436\u0438\u0434\u0430\u0435\u043C \u043E\u0442\u0432\u0435\u0442\u044B \u0441 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u043C\u0438...");
      await Promise.all(metadataPromises);
      console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u043E\u0442 ${this.deviceFileMetadata.size} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 \u0438\u0437 ${trustedDevices.length}`);
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445:", error);
    }
  }
  /**
   * Обработчик запроса метаданных от других устройств
   */
  handleFileMetadataRequest(message) {
    if (!message.sourceDeviceId || !message.requestId)
      return;
    console.log(`\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u0437\u0430\u043F\u0440\u043E\u0441 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u043E\u0442 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${message.deviceName || message.sourceDeviceId}`);
    this.sendFileMetadata(message.sourceDeviceId, message.requestId);
  }
  /**
   * Отправить метаданные файлов другому устройству
   */
  async sendFileMetadata(targetDeviceId, requestId) {
    try {
      console.log(`\u041E\u0442\u043F\u0440\u0430\u0432\u043A\u0430 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0443 ${targetDeviceId}...`);
      const metadataToSend = {};
      for (const [path, metadata] of Object.entries(this.syncState.files)) {
        if (metadata.deleted)
          continue;
        metadataToSend[path] = {
          hash: metadata.hash,
          mtime: metadata.mtime,
          size: metadata.size,
          // Добавляем deleted только если он true
          ...metadata.deleted ? { deleted: true } : {}
        };
      }
      this.relayClient.sendMessage({
        type: "fileMetadata",
        targetDeviceId,
        requestId,
        payload: metadataToSend
      });
      console.log(`\u041C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u044B: ${Object.keys(metadataToSend).length} \u0444\u0430\u0439\u043B\u043E\u0432`);
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445:", error);
    }
  }
  /**
   * Определить, нужно ли синхронизировать файл с другими устройствами
   * на основе сравнения локальных метаданных и метаданных с других устройств
   */
  fileNeedsSync(path, metadata, trustedDevices) {
    const fiveMinutesAgo = Date.now() - 5 * 60 * 1e3;
    const isNew = metadata.mtime > fiveMinutesAgo;
    const targetDevices = [];
    let needsSync = false;
    for (const device of trustedDevices) {
      const deviceId = typeof device === "string" ? device : device.id;
      const deviceName = typeof device === "string" ? deviceId : device.name || deviceId;
      const deviceMetadata = this.deviceFileMetadata.get(deviceId);
      if (!deviceMetadata) {
        console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u041D\u0435\u0442 \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0445 \u0441 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430 ${deviceName} \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u0430 ${path}`);
        targetDevices.push(deviceId);
        needsSync = true;
        continue;
      }
      const remoteFile = deviceMetadata[path];
      if (!remoteFile) {
        console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0424\u0430\u0439\u043B ${path} \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u043D\u0430 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0435 ${deviceName}`);
        targetDevices.push(deviceId);
        needsSync = true;
        continue;
      }
      if (remoteFile.hash !== metadata.hash) {
        console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0425\u0435\u0448\u0438 \u0444\u0430\u0439\u043B\u0430 ${path} \u0440\u0430\u0437\u043B\u0438\u0447\u0430\u044E\u0442\u0441\u044F: \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0439 ${metadata.hash.substring(0, 8)}, \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u044B\u0439 ${remoteFile.hash.substring(0, 8)}`);
        targetDevices.push(deviceId);
        needsSync = true;
        continue;
      }
      if (metadata.mtime > remoteFile.mtime) {
        console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0412\u0440\u0435\u043C\u044F \u043C\u043E\u0434\u0438\u0444\u0438\u043A\u0430\u0446\u0438\u0438 \u0444\u0430\u0439\u043B\u0430 ${path} \u043D\u043E\u0432\u0435\u0435: \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u0435 ${new Date(metadata.mtime).toISOString()}, \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u043E\u0435 ${new Date(remoteFile.mtime).toISOString()}`);
        targetDevices.push(deviceId);
        needsSync = true;
      } else {
        console.log(`\u0421\u0418\u0413\u041D\u0410\u041B\u042C\u041D\u0410\u042F \u0421\u0418\u0421\u0422\u0415\u041C\u0410: \u0424\u0430\u0439\u043B ${path} \u0438\u0434\u0435\u043D\u0442\u0438\u0447\u0435\u043D \u043D\u0430 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0435 ${deviceName}`);
      }
    }
    if (isNew && targetDevices.length === 0) {
      console.log(`\u0424\u0430\u0439\u043B ${path} \u043D\u0435\u0434\u0430\u0432\u043D\u043E \u0438\u0437\u043C\u0435\u043D\u0435\u043D, \u043D\u043E \u043C\u0435\u0442\u0430\u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u0434\u0435\u043D\u0442\u0438\u0447\u043D\u044B \u043D\u0430 \u0432\u0441\u0435\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u0445 - \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F`);
      needsSync = false;
    } else if (isNew && targetDevices.length > 0) {
      console.log(`\u0424\u0430\u0439\u043B ${path} \u043D\u0435\u0434\u0430\u0432\u043D\u043E \u0438\u0437\u043C\u0435\u043D\u0435\u043D, \u0431\u0443\u0434\u0435\u0442 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D \u0441 ${targetDevices.length} \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u043C\u0438`);
      needsSync = true;
    }
    return { needsSync, isNew, targetDevices };
  }
  /**
   * Запустить принудительную полную синхронизацию
   */
  async forceFullSync() {
    console.log("\u0417\u0430\u043F\u0443\u0441\u043A \u043F\u0440\u0438\u043D\u0443\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u043F\u043E\u043B\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438...");
    new import_obsidian4.Notice("\u0417\u0430\u043F\u0443\u0441\u043A \u043F\u0440\u0438\u043D\u0443\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0439 \u043F\u043E\u043B\u043D\u043E\u0439 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
    this.isSyncing = false;
    await this.performFullSync();
  }
  /**
   * Обновить локальное состояние файлов
   */
  async updateLocalFileState() {
    const changes = await this.fileWatcher.scanAllFiles();
    const newState = {};
    for (const change of changes) {
      const file = change.file;
      const content = await this.app.vault.read(file);
      const hash = await CryptoHelper.hashString(content);
      newState[file.path] = {
        path: file.path,
        hash,
        mtime: file.stat.mtime,
        size: file.stat.size
      };
    }
    for (const [path, metadata] of Object.entries(this.syncState.files)) {
      if (metadata.deleted && !newState[path]) {
        newState[path] = metadata;
      }
    }
    this.syncState.files = newState;
    this.saveSyncState();
  }
  /**
   * Загрузить состояние синхронизации из локального хранилища
   */
  loadSyncState() {
    const savedState = localStorage.getItem("relay-sync-state");
    if (savedState) {
      try {
        return JSON.parse(savedState);
      } catch (error) {
        console.error("Error parsing saved sync state:", error);
      }
    }
    return {
      deviceId: DeviceManager.getDeviceId(),
      files: {},
      lastSyncTime: 0
    };
  }
  /**
   * Сохранить состояние синхронизации в локальное хранилище
   */
  saveSyncState() {
    localStorage.setItem("relay-sync-state", JSON.stringify(this.syncState));
  }
  /**
   * Получить список доверенных устройств
   */
  getTrustedDevices() {
    return this.trustedDevices;
  }
  /**
   * Отозвать доверие у устройства
   */
  async revokeTrust(deviceId) {
    try {
      return await this.relayClient.revokeTrust(deviceId);
    } catch (error) {
      console.error("Error revoking trust:", error);
      return false;
    }
  }
  /**
   * Сгенерировать ключ приглашения
   */
  async generateInvitationKey(expirationMinutes = 10) {
    try {
      return await this.relayClient.generateInvitationKey(expirationMinutes);
    } catch (error) {
      console.error("Error generating invitation key:", error);
      throw error;
    }
  }
  /**
   * Использовать ключ приглашения
   */
  async useInvitationKey(key) {
    try {
      return await this.relayClient.useInvitationKey(key);
    } catch (error) {
      console.error("Error using invitation key:", error);
      return false;
    }
  }
  /**
   * Проверить состояние подключения
   */
  isConnected() {
    return this.relayClient.isConnected;
  }
  /**
   * Обновить настройки синхронизации
   */
  updateOptions(options) {
    if (options.serverUrl) {
      this.options.serverUrl = options.serverUrl;
      this.relayClient.disconnect();
      this.relayClient = new RelayClient({
        serverUrl: this.options.serverUrl,
        deviceId: this.syncState.deviceId,
        deviceName: DeviceManager.getDeviceName(),
        onMessage: this.handleSyncMessage.bind(this),
        onConnectionChange: this.handleConnectionChange.bind(this),
        onTrustedDevicesChange: this.handleTrustedDevicesChange.bind(this),
        onSyncRequest: this.handleSyncRequest.bind(this)
      });
      this.relayClient.connect();
    }
    if (options.encryptionPassword) {
      this.options.encryptionPassword = options.encryptionPassword;
      this.encryptionPassword = options.encryptionPassword;
    }
    if (options.ignoredPaths) {
      this.options.ignoredPaths = options.ignoredPaths;
      for (const path of options.ignoredPaths) {
        this.fileWatcher.addIgnorePattern(new RegExp(path));
      }
    }
    if (options.fullSyncInterval !== void 0 && options.fullSyncInterval !== this.options.fullSyncInterval) {
      this.options.fullSyncInterval = options.fullSyncInterval;
      if (this.fullSyncInterval) {
        clearInterval(this.fullSyncInterval);
        this.fullSyncInterval = null;
      }
      if (options.fullSyncInterval) {
        this.fullSyncInterval = setInterval(
          this.performFullSync.bind(this),
          options.fullSyncInterval
        );
      }
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  serverUrl: "ws://176.53.161.220:8080/ws",
  encryptionPassword: "",
  ignoredPaths: [
    ".obsidian/",
    ".git/",
    ".sync/"
  ],
  fullSyncInterval: 30 * 60 * 1e3,
  // 30 минут
  autoConnect: true
  // Изменено на true для автоматического подключения
};
var RelaySyncPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.syncManager = null;
    this.statusBarItem = null;
    /**
     * Запуск обновлений статуса
     */
    this.statusUpdateInterval = null;
  }
  async onload() {
    console.log("Loading Relay Sync plugin");
    await this.loadSettings();
    if (this.settings.autoConnect === void 0) {
      console.log("\u0410\u0432\u0442\u043E\u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u043D\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D\u043E, \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0435\u043C \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: true");
      this.settings.autoConnect = true;
      await this.saveSettings();
    }
    this.addSettingTab(new RelaySyncSettingsTab(this.app, this));
    this.statusBarItem = new StatusBarItem(this.addStatusBarItem());
    this.addCommands();
    if (this.settings.autoConnect && this.settings.serverUrl && this.settings.encryptionPassword) {
      console.log("\u0410\u0432\u0442\u043E\u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u043D\u043E, \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0430\u0435\u043C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443...");
      setTimeout(() => {
        this.startSync().catch((error) => {
          console.error("Error auto-connecting:", error);
          new import_obsidian5.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u0430\u0432\u0442\u043E\u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F: " + error.message);
        });
      }, 2e3);
    } else {
      console.log("\u0410\u0432\u0442\u043E\u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u043D\u0435 \u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u043D\u043E: autoConnect=" + this.settings.autoConnect);
    }
  }
  /**
   * Регистрация команд плагина
   */
  addCommands() {
    this.addCommand({
      id: "toggle-sync",
      name: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C/\u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E",
      callback: async () => {
        var _a;
        if ((_a = this.syncManager) == null ? void 0 : _a.isConnected()) {
          this.stopSync();
        } else {
          await this.startSync();
        }
      }
    });
    this.addCommand({
      id: "full-sync",
      name: "\u0412\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u043F\u043E\u043B\u043D\u0443\u044E \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044E",
      callback: async () => {
        var _a, _b, _c, _d;
        if (!((_a = this.syncManager) == null ? void 0 : _a.isConnected())) {
          new import_obsidian5.Notice("\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
          return;
        }
        const syncState = this.syncManager["syncState"];
        const fileCount = Object.keys((syncState == null ? void 0 : syncState.files) || {}).length;
        (_b = this.statusBarItem) == null ? void 0 : _b.setStatus("syncing" /* SYNCING */, {
          syncProgress: 0,
          filesTotal: fileCount,
          filesChanged: 0
        });
        try {
          const startTime = Date.now();
          const progressTracker = setInterval(() => {
            var _a2;
            if (!this.syncManager || !this.syncManager["isSyncing"]) {
              clearInterval(progressTracker);
              return;
            }
            const progressValue = Math.min(90, (Date.now() - startTime) / 500);
            (_a2 = this.statusBarItem) == null ? void 0 : _a2.setStatus("syncing" /* SYNCING */, {
              syncProgress: Math.floor(progressValue)
            });
          }, 1e3);
          await this.syncManager.performFullSync();
          clearInterval(progressTracker);
          const updatedSyncState = this.syncManager["syncState"];
          (_c = this.statusBarItem) == null ? void 0 : _c.setStatus("connected" /* CONNECTED */, {
            lastSyncTime: (updatedSyncState == null ? void 0 : updatedSyncState.lastSyncTime) || Date.now(),
            filesTotal: Object.keys((updatedSyncState == null ? void 0 : updatedSyncState.files) || {}).length,
            syncProgress: 100
          });
          new import_obsidian5.Notice("\u041F\u043E\u043B\u043D\u0430\u044F \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0430");
        } catch (error) {
          console.error("Error during full sync:", error);
          (_d = this.statusBarItem) == null ? void 0 : _d.setStatus("error" /* ERROR */, {
            errorMessage: error.message
          });
          new import_obsidian5.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438: " + error.message);
        }
      }
    });
    this.addCommand({
      id: "generate-invitation-key",
      name: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043A\u043B\u044E\u0447 \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u044F",
      callback: async () => {
        var _a;
        if (!((_a = this.syncManager) == null ? void 0 : _a.isConnected())) {
          new import_obsidian5.Notice("\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443");
          return;
        }
        try {
          const key = await this.syncManager.generateInvitationKey();
          navigator.clipboard.writeText(key).then(() => {
            new import_obsidian5.Notice("\u041A\u043B\u044E\u0447 \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430: " + key);
          });
        } catch (error) {
          console.error("Error generating invitation key:", error);
          new import_obsidian5.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u043A\u043B\u044E\u0447\u0430: " + error.message);
        }
      }
    });
  }
  /**
   * Запуск процесса синхронизации
   */
  async startSync() {
    var _a, _b, _c;
    if (!this.settings.serverUrl) {
      new import_obsidian5.Notice("\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C URL \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
      return;
    }
    if (!this.settings.encryptionPassword) {
      new import_obsidian5.Notice("\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u043F\u0430\u0440\u043E\u043B\u044C \u0448\u0438\u0444\u0440\u043E\u0432\u0430\u043D\u0438\u044F");
      return;
    }
    let serverUrl = this.settings.serverUrl;
    if (serverUrl.startsWith("wss://https//") || serverUrl.startsWith("wss://http//")) {
      serverUrl = "wss://" + serverUrl.substring(serverUrl.indexOf("//") + 2);
      this.settings.serverUrl = serverUrl;
      await this.saveSettings();
      new import_obsidian5.Notice("URL \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0431\u044B\u043B \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0438\u0441\u043F\u0440\u0430\u0432\u043B\u0435\u043D");
    }
    try {
      this.syncManager = new SyncManager(this.app, {
        serverUrl,
        encryptionPassword: this.settings.encryptionPassword,
        ignoredPaths: this.settings.ignoredPaths,
        fullSyncInterval: this.settings.fullSyncInterval
      });
      (_a = this.statusBarItem) == null ? void 0 : _a.setStatus("syncing" /* SYNCING */, {
        syncProgress: 0,
        filesChanged: 0
      });
      await this.syncManager.start();
      this.startStatusUpdates();
      const trustedDevices = this.syncManager.getTrustedDevices();
      const syncState = this.syncManager["syncState"];
      (_b = this.statusBarItem) == null ? void 0 : _b.setStatus("connected" /* CONNECTED */, {
        lastSyncTime: (syncState == null ? void 0 : syncState.lastSyncTime) || Date.now(),
        filesTotal: Object.keys((syncState == null ? void 0 : syncState.files) || {}).length,
        trustedDevices: (trustedDevices == null ? void 0 : trustedDevices.length) || 0
      });
      new import_obsidian5.Notice("\u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
    } catch (error) {
      console.error("Error starting sync:", error);
      (_c = this.statusBarItem) == null ? void 0 : _c.setStatus("error" /* ERROR */, {
        errorMessage: error.message
      });
      new import_obsidian5.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438: " + error.message);
    }
  }
  startStatusUpdates() {
    if (this.statusUpdateInterval) {
      clearInterval(this.statusUpdateInterval);
    }
    this.statusUpdateInterval = setInterval(() => {
      var _a, _b, _c;
      if (!this.syncManager)
        return;
      try {
        const isConnected = this.syncManager.isConnected();
        const isSyncing = this.syncManager["isSyncing"];
        const syncState = this.syncManager["syncState"];
        const trustedDevices = this.syncManager.getTrustedDevices();
        const statsUpdate = {
          lastSyncTime: (syncState == null ? void 0 : syncState.lastSyncTime) || Date.now(),
          filesTotal: Object.keys((syncState == null ? void 0 : syncState.files) || {}).length,
          trustedDevices: (trustedDevices == null ? void 0 : trustedDevices.length) || 0
        };
        if (!isConnected) {
          (_a = this.statusBarItem) == null ? void 0 : _a.setStatus("disconnected" /* DISCONNECTED */);
        } else if (isSyncing) {
          (_b = this.statusBarItem) == null ? void 0 : _b.setStatus("syncing" /* SYNCING */, statsUpdate);
        } else {
          (_c = this.statusBarItem) == null ? void 0 : _c.setStatus("connected" /* CONNECTED */, statsUpdate);
        }
      } catch (error) {
        console.error("Error updating status:", error);
      }
    }, 5e3);
  }
  /**
   * Остановка процесса синхронизации
   */
  stopSync() {
    var _a, _b;
    try {
      if (this.statusUpdateInterval) {
        clearInterval(this.statusUpdateInterval);
        this.statusUpdateInterval = null;
      }
      if (this.syncManager) {
        this.syncManager.stop();
        this.syncManager = null;
      }
      (_a = this.statusBarItem) == null ? void 0 : _a.setStatus("disconnected" /* DISCONNECTED */);
      new import_obsidian5.Notice("\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u043E\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441\u0438\u043D\u0445\u0440\u043E\u043D\u0438\u0437\u0430\u0446\u0438\u0438");
    } catch (error) {
      console.error("Error stopping sync:", error);
      (_b = this.statusBarItem) == null ? void 0 : _b.setStatus("error" /* ERROR */, {
        errorMessage: error.message
      });
      new import_obsidian5.Notice("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438: " + error.message);
    }
  }
  /**
   * Обновление настроек синхронизации
   */
  updateSyncOptions() {
    if (this.syncManager) {
      this.syncManager.updateOptions({
        serverUrl: this.settings.serverUrl,
        encryptionPassword: this.settings.encryptionPassword,
        ignoredPaths: this.settings.ignoredPaths,
        fullSyncInterval: this.settings.fullSyncInterval
      });
    }
  }
  async onunload() {
    console.log("Unloading Relay Sync plugin");
    if (this.statusUpdateInterval) {
      clearInterval(this.statusUpdateInterval);
      this.statusUpdateInterval = null;
    }
    if (this.syncManager) {
      this.syncManager.stop();
      this.syncManager = null;
    }
  }
  async loadSettings() {
    const savedData = await this.loadData();
    if (savedData) {
      savedData.autoConnect = true;
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, savedData);
    this.settings.autoConnect = true;
    await this.saveSettings();
    console.log("\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B, autoConnect =", this.settings.autoConnect);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
